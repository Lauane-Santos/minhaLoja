/**
 * The `http2` module provides an implementation of the [HTTP/2](https://tools.ietf.org/html/rfc7540) protocol. It
 * can be accessed using:
 *
 * ```js
 * const http2 = require('http2');
 * ```
 * @since v8.4.0
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/http2.js)
 */
declare module 'http2' {
    import EventEmitter = require('node:events');
    import * as fs from 'node:fs';
    import * as net from 'node:net';
    import * as stream from 'node:stream';
    import * as tls from 'node:tls';
    import * as url from 'node:url';
    import { IncomingHttpHeaders as Http1IncomingHttpHeaders, OutgoingHttpHeaders, IncomingMessage, ServerResponse } from 'node:http';
    export { OutgoingHttpHeaders } from 'node:http';
    export interface IncomingHttpStatusHeader {
        ':status'?: number | undefined;
    }
    export interface IncomingHttpHeaders extends Http1IncomingHttpHeaders {
        ':path'?: string | undefined;
        ':method'?: string | undefined;
        ':authority'?: string | undefined;
        ':scheme'?: string | undefined;
    }
    // Http2Stream
    export interface StreamPriorityOptions {
        exclusive?: boolean | undefined;
        parent?: number | undefined;
        weight?: number | undefined;
        silent?: boolean | undefined;
    }
    export interface StreamState {
        localWindowSize?: number | undefined;
        state?: number | undefined;
        localClose?: number | undefined;
        remoteClose?: number | undefined;
        sumDependencyWeight?: number | undefined;
        weight?: number | undefined;
    }
    export interface ServerStreamResponseOptions {
        endStream?: boolean | undefined;
        waitForTrailers?: boolean | undefined;
    }
    export interface StatOptions {
        offset: number;
        length: number;
    }
    export interface ServerStreamFileResponseOptions {
        statCheck?(stats: fs.Stats, headers: OutgoingHttpHeaders, statOptions: StatOptions): void | boolean;
        waitForTrailers?: boolean | undefined;
        offset?: number | undefined;
        length?: number | undefined;
    }
    export interface ServerStreamFileResponseOptionsWithError extends ServerStreamFileResponseOptions {
        onError?(err: NodeJS.ErrnoException): void;
    }
    export interface Http2Stream extends stream.Duplex {
        /**
         * Set to `true` if the `Http2Stream` instance was aborted abnormally. When set,
         * the `'aborted'` event will have been emitted.
         * @since v8.4.0
         */
        readonly aborted: boolean;
        /**
         * This property shows the number of characters currently buffered to be written.
         * See `net.Socket.bufferSize` for details.
         * @since v11.2.0, v10.16.0
         */
        readonly bufferSize: number;
        /**
         * Set to `true` if the `Http2Stream` instance has been closed.
         * @since v9.4.0
         */
        readonly closed: boolean;
        /**
         * Set to `true` if the `Http2Stream` instance has been destroyed and is no longer
         * usable.
         * @since v8.4.0
         */
        readonly destroyed: boolean;
        /**
         * Set to `true` if the `END_STREAM` flag was set in the request or response
         * HEADERS frame received, indicating that no additional data should be received
         * and the readable side of the `Http2Stream` will be closed.
         * @since v10.11.0
         */
        readonly endAfterHeaders: boolean;
        /**
         * The numeric stream identifier of this `Http2Stream` instance. Set to `undefined`if the stream identifier has not yet been assigned.
         * @since v8.4.0
         */
        readonly id?: number | undefined;
        /**
         * Set to `true` if the `Http2Stream` instance has not yet been assigned a
         * numeric stream identifier.
         * @since v9.4.0
         */
        readonly pending: boolean;
        /**
         * Set to the `RST_STREAM` `error code` reported when the `Http2Stream` is
         * destroyed after either receiving an `RST_STREAM` frame from the connected peer,
         * calling `http2stream.close()`, or `http2stream.destroy()`. Will be`undefined` if the `Http2Stream` has not been closed.
         * @since v8.4.0
         */
        readonly rstCode: number;
        /**
         * An object containing the outbound headers sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentHeaders: OutgoingHttpHeaders;
        /**
         * An array of objects containing the outbound informational (additional) headers
         * sent for this `Http2Stream`.
         * @since v9.5.0
         */
        readonly sentInfoHeaders?: OutgoingHttpHeaders[] | undefined;
        /**
         * An object containing the outbound trailers sent for this `HttpStream`.
         * @since v9.5.0
         */
        readonly sentTrailers?: OutgoingHttpHeaders | undefined;
        /**
         * A reference to the `Http2Session` instance that owns this `Http2Stream`. The
         * value will be `undefined` after the `Http2Stream` instance is destroyed.
         * @since v8.4.0
         */
        readonly session: Http2Session;
        /**
         * Provides miscellaneous information about the current state of the`Http2Stream`.
         *
         * A current state of this `Http2Stream`.
         * @since v8.4.0
         */
        readonly state: StreamState;
        /**
         * Closes the `Http2Stream` instance by sending an `RST_STREAM` frame to the
         * connected HTTP/2 peer.
         * @since v8.4.0
         * @param [code=http2.constants.NGHTTP2_NO_ERROR] Unsigned 32-bit integer identifying the error code.
         * @param callback An optional function registered to listen for the `'close'` event.
         */
        close(code?: number, callback?: () => void): void;
        /**
         * Updates the priority for this `Http2Stream` instance.
         * @since v8.4.0
         */
        priority(options: StreamPriorityOptions): void;
        /**
         * ```js
         * const http2 = require('http2');
         * const client = http2.connect('http://example.org:8000');
         * const { NGHTTP2_CANCEL } = http2.constants;
         * const req = client.request({ ':path': '/' });
         *
         * // Cancel the stream if there's no activity after 5 seconds
         * req.setTimeout(5000, () => req.close(NGHTTP2_CANCEL));
         * ```
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Sends a trailing `HEADERS` frame to the connected HTTP/2 peer. This method
         * will cause the `Http2Stream` to be immediately closed and must only be
         * called after the `'wantTrailers'` event has been emitted. When sending a
         * request or sending a response, the `options.waitForTrailers` option must be set
         * in order to keep the `Http2Stream` open after the final `DATA` frame so that
         * trailers can be sent.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond(undefined, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ xyz: 'abc' });
         *   });
         *   stream.end('Hello World');
         * });
         * ```
         *
         * The HTTP/1 specification forbids trailers from containing HTTP/2 pseudo-header
         * fields (e.g. `':method'`, `':path'`, etc).
         * @since v10.0.0
         */
        sendTrailers(headers: OutgoingHttpHeaders): void;
        addListener(event: 'aborted', listener: () => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        addListener(event: 'drain', listener: () => void): this;
        addListener(event: 'end', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'finish', listener: () => void): this;
        addListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        addListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        addListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        addListener(event: 'streamClosed', listener: (code: number) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'wantTrailers', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'aborted'): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'data', chunk: Buffer | string): boolean;
        emit(event: 'drain'): boolean;
        emit(event: 'end'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'finish'): boolean;
        emit(event: 'frameError', frameType: number, errorCode: number): boolean;
        emit(event: 'pipe', src: stream.Readable): boolean;
        emit(event: 'unpipe', src: stream.Readable): boolean;
        emit(event: 'streamClosed', code: number): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: 'trailers', trailers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'wantTrailers'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'aborted', listener: () => void): this;
        on(event: 'close', listener: () => void): this;
        on(event: 'data', listener: (chunk: Buffer | string) => void): this;
        on(event: 'drain', listener: () => void): this;
        on(event: 'end', listener: () => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'finish', listener: () => void): this;
        on(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        on(event: 'pipe', listener: (src: stream.Readable) => void): this;
        on(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        on(event: 'streamClosed', listener: (code: number) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'wantTrailers', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'aborted', listener: () => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'data', listener: (chunk: Buffer | string) => void): this;
        once(event: 'drain', listener: () => void): this;
        once(event: 'end', listener: () => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'finish', listener: () => void): this;
        once(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        once(event: 'pipe', listener: (src: stream.Readable) => void): this;
        once(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        once(event: 'streamClosed', listener: (code: number) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'wantTrailers', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'aborted', listener: () => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        prependListener(event: 'drain', listener: () => void): this;
        prependListener(event: 'end', listener: () => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'finish', listener: () => void): this;
        prependListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        prependListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: 'streamClosed', listener: (code: number) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'wantTrailers', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'aborted', listener: () => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        prependOnceListener(event: 'drain', listener: () => void): this;
        prependOnceListener(event: 'end', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'finish', listener: () => void): this;
        prependOnceListener(event: 'frameError', listener: (frameType: number, errorCode: number) => void): this;
        prependOnceListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: 'streamClosed', listener: (code: number) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: 'trailers', listener: (trailers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'wantTrailers', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Stream extends Http2Stream {
        addListener(event: 'continue', listener: () => {}): this;
        addListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'continue'): boolean;
        emit(event: 'headers', headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: 'push', headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'response', headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'continue', listener: () => {}): this;
        on(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'continue', listener: () => {}): this;
        once(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'continue', listener: () => {}): this;
        prependListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'continue', listener: () => {}): this;
        prependOnceListener(event: 'headers', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: 'push', listener: (headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'response', listener: (headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ServerHttp2Stream extends Http2Stream {
        /**
         * True if headers were sent, false otherwise (read-only).
         * @since v8.4.0
         */
        readonly headersSent: boolean;
        /**
         * Read-only property mapped to the `SETTINGS_ENABLE_PUSH` flag of the remote
         * client's most recent `SETTINGS` frame. Will be `true` if the remote peer
         * accepts push streams, `false` otherwise. Settings are the same for every`Http2Stream` in the same `Http2Session`.
         * @since v8.4.0
         */
        readonly pushAllowed: boolean;
        /**
         * Sends an additional informational `HEADERS` frame to the connected HTTP/2 peer.
         * @since v8.4.0
         */
        additionalHeaders(headers: OutgoingHttpHeaders): void;
        /**
         * Initiates a push stream. The callback is invoked with the new `Http2Stream`instance created for the push stream passed as the second argument, or an`Error` passed as the first argument.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.pushStream({ ':path': '/' }, (err, pushStream, headers) => {
         *     if (err) throw err;
         *     pushStream.respond({ ':status': 200 });
         *     pushStream.end('some pushed data');
         *   });
         *   stream.end('some data');
         * });
         * ```
         *
         * Setting the weight of a push stream is not allowed in the `HEADERS` frame. Pass
         * a `weight` value to `http2stream.priority` with the `silent` option set to`true` to enable server-side bandwidth balancing between concurrent streams.
         *
         * Calling `http2stream.pushStream()` from within a pushed stream is not permitted
         * and will throw an error.
         * @since v8.4.0
         * @param callback Callback that is called once the push stream has been initiated.
         */
        pushStream(headers: OutgoingHttpHeaders, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;
        pushStream(headers: OutgoingHttpHeaders, options?: StreamPriorityOptions, callback?: (err: Error | null, pushStream: ServerHttp2Stream, headers: OutgoingHttpHeaders) => void): void;
        /**
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 });
         *   stream.end('some data');
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('http2');
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   stream.respond({ ':status': 200 }, { waitForTrailers: true });
         *   stream.on('wantTrailers', () => {
         *     stream.sendTrailers({ ABC: 'some value to send' });
         *   });
         *   stream.end('some data');
         * });
         * ```
         * @since v8.4.0
         */
        respond(headers?: OutgoingHttpHeaders, options?: ServerStreamResponseOptions): void;
        /**
         * Initiates a response whose data is read from the given file descriptor. No
         * validation is performed on the given file descriptor. If an error occurs while
         * attempting to read data using the file descriptor, the `Http2Stream` will be
         * closed using an `RST_STREAM` frame using the standard `INTERNAL_ERROR` code.
         *
         * When used, the `Http2Stream` object's `Duplex` interface will be closed
         * automatically.
         *
         * ```js
         * const http2 = require('http2');
         * const fs = require('fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
         *     'content-type': 'text/plain; charset=utf-8'
         *   };
         *   stream.respondWithFD(fd, headers);
         *   stream.on('close', () => fs.closeSync(fd));
         * });
         * ```
         *
         * The optional `options.statCheck` function may be specified to give user code
         * an opportunity to set additional content headers based on the `fs.Stat` details
         * of the given fd. If the `statCheck` function is provided, the`http2stream.respondWithFD()` method will perform an `fs.fstat()` call to
         * collect details on the provided file descriptor.
         *
         * The `offset` and `length` options may be used to limit the response to a
         * specific range subset. This can be used, for instance, to support HTTP Range
         * requests.
         *
         * The file descriptor or `FileHandle` is not closed when the stream is closed,
         * so it will need to be closed manually once it is no longer needed.
         * Using the same file descriptor concurrently for multiple streams
         * is not supported and may result in data loss. Re-using a file descriptor
         * after a stream has finished is supported.
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * will be emitted immediately after queuing the last chunk of payload data to be
         * sent. The `http2stream.sendTrailers()` method can then be used to sent trailing
         * header fields to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code _must_ call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * ```js
         * const http2 = require('http2');
         * const fs = require('fs');
         *
         * const server = http2.createServer();
         * server.on('stream', (stream) => {
         *   const fd = fs.openSync('/some/file', 'r');
         *
         *   const stat = fs.fstatSync(fd);
         *   const headers = {
         *     'content-length': stat.size,
         *     'last-modified': stat.mtime.toUTCString(),
       pL‹L$`I‹
¸   L9Éƒ6  ¶>D9ß‡5  @„ÿx f‰9HÿÆI‰0I‹
HƒÁI‰
I‹0H9ÖrÆé  @€ÿÂ‚  @€ÿßwFH‰ÓH)óHƒûŒå  ¶^‰ØƒàÀ=€   …Ü  ƒçÁçƒã?	û¸   D9Û‡¸  f‰HƒÆë@€ÿïw8H‰ÓH)óHƒûŒ™  D¶v¶^@€ÿít`·ïD‰ğıà   uY$à< t]é|  @€ÿô‡r  H‰ÓH)óHƒûŒW  D¶fD¶vD¶~@€ÿôtjÿğ   ujAt$p@€ş0rné5  D‰ğ$àë$À<€…$  ‰ØƒàÀ=€   …  ÁçAƒæ?AÁæA	şƒã?D	ó·û¸   D9ß‡ä   f‰HƒÆé¹şÿÿD‰ã€ãğëD‰ã€ãÀ€û€…Ì   D‰öƒæÀş€   …º   D‰şƒæÀş€   …¨   L‰ÎH)ÎHƒşŒ   ƒç‰øÁàD‰ãƒã?Áã	ÃD‰öÁæ‰õåÀ  	İAƒç?D	ı¸   D9İwYÁçAÁäD‰à%À   	øAƒä<A	ÄAÁîAƒæC&À?   Ø  f‰æÀ  B> Ü  HqI‰2f‰AI‹0HƒÆéãıÿÿ1À[]_^A\A^A_Ã¸   ëîÌHƒì(L‰ÊL‰ÁL‹D$PÇD$     A¹ÿÿ è   HƒÄ(ÃÌÌÌÌÌÌÌÌAVVWUSH‰ÓH)ËH‰ÈHƒû|-‹\$PH‰Èƒãt!€9ïH‰Èu€y»H‰Èu1À€y¿”ÀH@HÈH9Ğƒ¿  M…À„¶  E1ÒD¶E9Ë‡¦  E„ÛxHÿÀH9Ğƒ•  IÿÂM9ÂrÚéˆ  A€ûÂ‚~  A€ûßwFH‰ÖH)ÆHƒşŒh  ¶p‰÷ƒçÀÿ€   …S  AƒãAÁãƒæ?D	Ş1ÛD9Î–ÃHXv™é2  A€ûïw6H‰ÖH)ÆHƒşŒ  ¶p¶x‰óA€ûítjAûà   uf€ãà€û tjéö   A€ûô‡ì   H‰ÖH)ÆHƒşŒÜ   L‰ÆL)ÖHƒş‚Ì   ¶x¶pD¶pA€ûôt\Aûğ   uZop@€ı0r[é¢   €ãàë€ãÀ€û€…‘   ‰ûƒãÀû€   …€   AÁãA·Ûƒæ?Áæ	Şƒç?	÷D9ÏwfHƒÀé¿şÿÿ‰û€ãğë‰û€ãÀ€û€uL‰óƒãÀû€   u?D‰óƒãÀû€   u1AƒãAÁãƒç?ÁçD	ßƒæ?Áæ	şAƒæ?A	öE9ÎwIÿÂHƒÀébşÿÿ)È[]_^A^ÃÌÌÌÌÌÌÌÌÌÌÌÌÌ¸   ÃÌÌÌÌÌÌÌÌÌÌAWAVVWSHƒì`L‰ÊL‰ÁL‹´$È   L‹¼$°   H‹„$À   L‹Œ$¸   H‹=0_ H1çH‰|$XHt$PL‰H\$HL‰H‰\$(H‰D$ ÇD$8    ÇD$0ÿÿ I‰ğè.   ‰ÇH‹I‰H‹I‰H‹L$XH1áè³Íûÿ‰øHƒÄ`[_^A^A_ÃÌÌÌÌÌVWL‹T$@L‹\$8I‰M‰
öD$P…"  I‹ H9Ğƒ  D‹L$H‹¸   D9É‡ş   ‰Îæ øÿÿş Ø  „ê   ƒùwI‹L‰ŞH)ÆH…öµ   é  ùÿ  w(I‹L‰ŞH)ÆHƒşŒñ   ‰ÎÁî@€ÎÀHxI‰:@ˆ0ëwI‹L‰ŞH)Æùÿÿ  wHƒşŒÁ   ‰ÎÁî@€ÎàHxI‰:@ˆ0ë2HƒşŒ¢   ‰ÎÁî@€ÎğHxI‰:@ˆ0‰ÈÁè$?€I‹2H~I‰:ˆ‰ÈÁè$?€I‹2H~I‰:ˆ€á?€É€I‹HpI‰2ˆI‹ HƒÀI‰ H9Ğ‚ôşÿÿ1À_^ÃL‰ÙL)É¸   Hƒù|ìIAI‰AÆïI‹HHI‰
Æ »I‹HHI‰
Æ ¿é£şÿÿ¸   ë»ÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌAWAVVWSHƒì`L‰ÊL‰ÁL‹´$È   L‹¼$°   H‹„$À   L‹Œ$¸   H‹= ] H1çH‰|$XHt$PL‰H\$HL‰H‰\$(H‰D$ ÇD$8    ÇD$0ÿÿ I‰ğè.   ‰ÇH‹I‰H‹I‰H‹L$XH1áèƒËûÿ‰øHƒÄ`[_^A^A_ÃÌÌÌÌÌAWAVVWUSL‹T$`I‰M‰
I‹öD$pt$H‰ĞH)ÈHƒø|€9ïu€y»u€y¿uHƒÁI‰H9ÑƒÃ  D‹L$hL‹\$XI‹2¸   L9Şƒª  ¶9@„ÿx-½   D9Ï‡  ‰>HéI‰I‹2HƒÆI‰2I‹H9ÑrÂés  @€ÿÂ‚t  @€ÿßwDH‰ÓH)ËHƒûŒU  ¶A‰ÃƒãÀû€   …I  ƒçÁçƒà?	Ç½   ¸   D9Ïv’é!  @€ÿïw6H‰ÓH)ËHƒûŒ  ¶AD¶q‰Ã@€ÿítYÿà   uV€ãà€û tZéî   @€ÿô‡ä   H‰ÓH)ËHƒûŒË   ¶YD¶yD¶q@€ÿôtfÿğ   udkp@€ı0rcéª   €ãàë€ãÀ€û€…™   D‰óƒãÀû€   …‡   Áç·ÿƒà?Áà	øAƒæ?A	Æ½   D‰÷¸   E9Î†¿şÿÿëQ‰Ø$ğë‰Ø$À<€uLD‰øƒàÀ=€   u?D‰ğƒàÀ=€   u2ƒçÁçƒã?Áã	ûAƒç?AÁçA	ßAƒæ?E	ş½   ë1À[]_^A^A_Ã¸   ëğÌHƒì(L‰ÊL‰ÁL‹D$PÇD$     A¹ÿÿ è   HƒÄ(ÃÌÌÌÌÌÌÌÌAVVWUSH‰ÓH)ËH‰ÈHƒû|-‹\$PH‰Èƒãt!€9ïH‰Èu€y»H‰Èu1À€y¿”ÀH@HÈH9Ğƒ¬  M…À„£  Aº   D¶E„Ûx+¿   E9Ë‡†  HøH9Ğƒz  IjM9ÂI‰êrÑéi  A€ûÂ‚_  A€ûßwBH‰ÖH)ÆHƒşŒI  ¶p‰÷ƒçÀÿ€   …4  AƒãAÁãƒæ?D	Ş¿   D9Îv–é  A€ûïw6H‰ÖH)ÆHƒşŒ  ¶x¶p‰ûA€ûítZAûà   uV€ãà€û tZéÛ   A€ûô‡Ñ   H‰ÖH)ÆHƒşŒÁ   ¶p¶xD¶pA€ûôtTAûğ   uRnp@€ı0rSé—   €ãàë€ãÀ€û€…†   ‰óƒãÀû€   uyAÁãA·Ûƒç?Áç	ßƒæ?	ş¿   é9ÿÿÿ‰ó€ãğë‰ó€ãÀ€û€uI‰ûƒãÀû€   u<D‰óƒãÀû€   u.AƒãAÁãƒæ?ÁæD	Şƒç?Áç	÷Aƒæ?A	ş¿   E9Î†zşÿÿ)È[]_^A^Ã·AÃÌÌÌÌÌÌÌÌÌÌÌ·AÃÌÌÌÌÌÌÌÌÌÌÌVHƒì H‰Ö€y/ xHƒÁH‹AH‰FH‰ğHƒÄ ^ÃH‹QL‹A H‰ñèGúÿëåÌÌÌÌÌVHƒì H‰ÖHÒ" H‰ñèirùÿH‰ğHƒÄ ^ÃVHƒì H‰ÖH¡8 H‰ñè‰ñ÷ÿH‰ğHƒÄ ^ÃVHƒì H‰ÖH—" H‰ñè)rùÿH‰ğHƒÄ ^ÃVHƒì H‰ÖHk8 H‰ñèIñ÷ÿH‰ğHƒÄ ^ÃAºárPAºá	rfŠ„ÀtHÿÂˆHÿÁŠHÿÂ„ÀuòD‰ÈƒàJƒøtƒø@tGE„Àºd   ¸u   EÂˆÃAºá“ÀÀàXëîD‰ÈƒàJƒøt¥ƒø@t E„Àt›Æ+HÿÁë“Æ#HÿÁë’°oëÅAºàreAºà
rfA¹  D‰ÀD!ÈD9Èt	fÇ.*HƒÁDŠ
E„ÉuL=   t%ƒøtV=  t_Aºà“ÂÀâ€ÊG=  •ÀˆÃAºà“ÂÀâ€ÊEëåÆ+HÿÁë“Æ#HÿÁë’HÿÂDˆ	HÿÁDŠ
HÿÂE„Ét ëíAºà“ÂÀâ€ÊFë¯Aºà“ÂÀâ€ÊAëŸÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(‹  ‹`ê eH‹%X   H‹Ê;   H‹t  HƒÄ(ÃHp  èÓ²ûÿƒ=d  ÿußè%   H¾! H‰G  HH  èC³ûÿë¾ÌÌÌÌÌÌÌÌÌHƒì(‹æ" ‹ğé eH‹%X   H‹Ê;   ~  €=‡!  ˆ/  Æz! H\! ·ª  f‰H‹œ  ‰Æ@ €=m!  ˆ  Æ`! HB! ·X  f‰H‹J  ‰Æ@ €=S!  ˆù  ÆF! H(! ‹-  ‰H‹!  ‰Æ@ €=;!  ˆà  Æ.! 	H! Š
  ˆHH‹ø H‰Æ@	 €=!!  ˆÅ  Æ! Hö  H¹ThursdayH‰Æ@ €=!  ˆ°  Æ ! Hâ  ·± f‰H‹£ ‰Æ@ €=ó   ˆ•  Ææ  HÈ  H¹SaturdayH‰Æ@ €=ß   ˆ€  ÆÒ  H´  Ç Sun €=Ö   ˆv  ÆÉ  H«  Ç Mon €=Í   ˆl  ÆÀ  H¢  Ç Tue €=Ä   ˆb  Æ·  H™  Ç Wed €=»   ˆX  Æ®  H  Ç Thu €=²   ˆN  Æ¥  H‡  Ç Fri €=©   ˆD  Æœ  H~  Ç Sat HƒÄ(ÃHÇ8    H‹) éÈıÿÿHÇ9    H‹* éãıÿÿHÇ:    H‹+ éşıÿÿHÇ; 	   H‹, éşÿÿHÇ<    H‹- é2şÿÿHÇ=    H‹. éGşÿÿHÇ>    H‹/ ébşÿÿHÇ?    H‹0 éwşÿÿHÇ@    H‹1 éşÿÿHÇA    H‹2 é‹şÿÿHÇB    H‹3 é•şÿÿHÇC    H‹4 éŸşÿÿHÇD    H‹5 é©şÿÿHÇE    H‹6 é³şÿÿHB èí®ûÿƒ=6 ÿ…iüÿÿHÙ A¸P  1ÒèÜáûÿHÕ  è4±ûÿH	 èL¯ûÿé8üÿÿÌÌÌÌÌÌÌÌÌÌÌÌÌÌÌHƒì(‹> ‹ğå eH‹%X   H‹Ê;   H‹ HƒÄ(ÃH èc®ûÿƒ= ÿußè%   H® H‰ç Hè èÓ®ûÿë¾ÌÌÌÌÌÌÌÌÌHƒì(‹Ö ‹€å eH‹%X   H‹Ê;     €=w  ˆÂ  Æj HL ‹öF ‰HH‹äF H‰fÇ@  €=[  ˆ¥  ÆN H0 ‹ĞF ‰HH‹¾F H‰fÇ@  €=?  ˆˆ  Æ2 H H‹§F H‰HH‹–F H‰fÇ@  €=!  ˆi  Æ 	Hö ·‹F f‰HpF  fÇ@  €=  ˆJ  Æö HØ YF  fÇ@  €=ğ  ˆ6  Æã HÅ ‹IF ‰HH‹7F H‰fÇ@  €=Ô  ˆ  ÆÇ H© F  fÇ@  €=Á  ˆ  Æ´ H– ·F f‰H‹÷E ‰fÇ@  €=¥  ˆè  Æ˜ Hz ·ÙE f‰H‹ËE ‰fÇ@  €=‰  ˆË  Æ| H^ ·­E f‰H‹ŸE ‰fÇ@  €=m  ˆ®  Æ` HB ·E f‰H‹sE ‰fÇ@  €=Q  ˆ‘  ÆD H& ·UE f‰H‹GE ‰fÇ@  €=5  ˆt  Æ( H
 ·)E f‰H‹E ‰fÇ@  €=  ˆW  Æ Hî ·ıD f‰H‹ïD ‰fÇ@  HƒÄ(ÃHÇ•    H‹† é5ıÿÿHÇ–    H‹‡ éRıÿÿHÇ—    H‹ˆ éoıÿÿHÇ˜ 	   H‹‰ éıÿÿHÇ™    H‹Š é­ıÿÿHÇš    H‹‹ éÁıÿÿHÇ›    H‹Œ éŞıÿÿHÇœ    H‹ éòıÿÿHÇ    H‹ éşÿÿHÇ    H‹ é,şÿÿHÇŸ    H‹ éIşÿÿHÇ     H‹‘ éfşÿÿHÇ¡    H‹’ éƒşÿÿHÇ¢    H‹“ é şÿÿHŸ èê©ûÿƒ=“ ÿ…ÖûÿÿH6 A¸P  1ÒèÙÜûÿH  è1¬ûÿHf èIªûÿé¥ûÿÿÌÌÌÌÌÌÌÌÌÌÌÌHƒì(‹N ‹ğà eH‹%X   H‹Ê;   H‹$ HƒÄ(ÃH  èc©ûÿƒ= ÿußè%   H H‰÷ Hø èÓ©ûÿë¾ÌÌÌÌÌÌÌÌÌHƒì(‹& ‹€à eH‹%X   H‹Ê;   §  €=×  ˆr  ÆÊ H¬ Ç@uaryÇ JanuÆ@ €=Ã  ˆ]  Æ¶ H˜ H¹FebruaryH‰Æ@ €=¯  ˆH  Æ¢ H„ Ç MarcfÇ@h €=   ˆ8  Æ“ Hu Ç AprifÇ@l €=‘  ˆ(  Æ„ Hf Ç May €=ˆ  ˆ  Æ{ H] Ç JuneÆ@ €={  ˆ  Æn HP Ç JulyÆ@ €=n  ˆ  Æa HC fÇ@stÇ AuguÆ@ €=[  ˆî  ÆN 	H0 H¹SeptembeH‰fÇ@r €=E  ˆ×  Æ8 H Ç@oberÇ OctoÆ@ €=1  ˆÂ  Æ$ H H¹NovemberH‰Æ@ €=  ˆ­  Æ Hò H¹DecemberH‰Æ@ €=	  ˆ˜  Æü HŞ Ç Jan €=   ˆ  Æó HÕ Ç Feb €=÷  ˆ„  Æê HÌ Ç Mar €=î  ˆz  Æá HÃ Ç Apr €=å  ˆp  ÆØ Hº Ç May €=Ü  ˆf  ÆÏ H± Ç Jun €=Ó  ˆ\  ÆÆ H¨ Ç Jul €=Ê  ˆR  Æ½ HŸ Ç Aug €=Á  ˆH  Æ´ H– Ç Sep €=¸  ˆ>  Æ« H Ç Oct €=¯  ˆ4  Æ¢ H„ Ç Nov €=¦  ˆ*  Æ™ H{ Ç Dec HƒÄ(ÃHÇE    H‹6 é…üÿÿHÇF    H‹7 éšüÿÿHÇG    H‹8 é¯üÿÿHÇH    H‹9 é¿üÿÿHÇI    H‹: éÏüÿÿHÇJ    H‹; éÙüÿÿHÇK    H‹< éçüÿÿHÇL    H‹= éõüÿÿHÇM 	   H‹> é	ıÿÿHÇN    H‹? é ıÿÿHÇO    H‹@ é5ıÿÿHÇP    H‹A éJıÿÿHÇQ    H‹B é_ıÿÿHÇR    H‹C éiıÿÿHÇS    H‹D ésıÿÿHÇT    H‹E é}ıÿÿHÇU    H‹F é‡ıÿÿHÇV    H‹G é‘ıÿÿHÇW    H‹H é›ıÿÿHÇX    H‹I é¥ıÿÿHÇY    H‹J é¯ıÿÿHÇZ    H‹K é¹ıÿÿHÇ[    H‹L éÃıÿÿHÇ\    H‹M éÍıÿÿHY èT£ûÿƒ=M ÿ…@úÿÿH  A¸@  1ÒèCÖûÿH¼  è›¥ûÿH  è³£ûÿéúÿÿÌÌÌÌÌÌHƒì(‹Î ‹`Ú eH‹%X   H‹Ê;   H‹¤ HƒÄ(ÃH  èÓ¢ûÿƒ=” ÿußè%   HÎ H‰w Hx èC£ûÿë¾ÌÌÌÌÌÌÌÌÌHƒì(‹æ ‹ğÙ eH‹%X   H‹Ê;   æ  €=—  ˆ±  ÆŠ Hl H‹< H‰HH‹ü; H‰fÇ@  €=y  ˆ’  Æl HN á;  fÇ@  €=f  ˆ~  ÆY H; ·Ğ; f‰HH‹½; H‰fÇ@
  €=H  ˆ_  Æ; H ·¦; f‰HH‹“; H‰fÇ@
  €=*  ˆ@  Æ Hÿ D·w; fD‰B‹h; ‰
fÇB  €=  ˆ!  Æÿ Há H¸J u n e H‰fÇB  €=ö  ˆ
  Æé HË H¸J u l y H‰fÇB  €=à  sion` is connected to a `TLSSocket`, the `originSet` property
         * will return an `Array` of origins for which the `Http2Session` may be
         * considered authoritative.
         *
         * The `originSet` property is only available when using a secure TLS connection.
         * @since v9.4.0
         */
        readonly originSet?: string[] | undefined;
        /**
         * Indicates whether the `Http2Session` is currently waiting for acknowledgment of
         * a sent `SETTINGS` frame. Will be `true` after calling the`http2session.settings()` method. Will be `false` once all sent `SETTINGS`frames have been acknowledged.
         * @since v8.4.0
         */
        readonly pendingSettingsAck: boolean;
        /**
         * A prototype-less object describing the current remote settings of this`Http2Session`. The remote settings are set by the _connected_ HTTP/2 peer.
         * @since v8.4.0
         */
        readonly remoteSettings: Settings;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * limits available methods to ones safe to use with HTTP/2.
         *
         * `destroy`, `emit`, `end`, `pause`, `read`, `resume`, and `write` will throw
         * an error with code `ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for more information.
         *
         * `setTimeout` method will be called on this `Http2Session`.
         *
         * All other interactions will be routed directly to the socket.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * Provides miscellaneous information about the current state of the`Http2Session`.
         *
         * An object describing the current status of this `Http2Session`.
         * @since v8.4.0
         */
        readonly state: SessionState;
        /**
         * The `http2session.type` will be equal to`http2.constants.NGHTTP2_SESSION_SERVER` if this `Http2Session` instance is a
         * server, and `http2.constants.NGHTTP2_SESSION_CLIENT` if the instance is a
         * client.
         * @since v8.4.0
         */
        readonly type: number;
        /**
         * Gracefully closes the `Http2Session`, allowing any existing streams to
         * complete on their own and preventing new `Http2Stream` instances from being
         * created. Once closed, `http2session.destroy()`_might_ be called if there
         * are no open `Http2Stream` instances.
         *
         * If specified, the `callback` function is registered as a handler for the`'close'` event.
         * @since v9.4.0
         */
        close(callback?: () => void): void;
        /**
         * Immediately terminates the `Http2Session` and the associated `net.Socket` or`tls.TLSSocket`.
         *
         * Once destroyed, the `Http2Session` will emit the `'close'` event. If `error`is not undefined, an `'error'` event will be emitted immediately before the`'close'` event.
         *
         * If there are any remaining open `Http2Streams` associated with the`Http2Session`, those will also be destroyed.
         * @since v8.4.0
         * @param error An `Error` object if the `Http2Session` is being destroyed due to an error.
         * @param code The HTTP/2 error code to send in the final `GOAWAY` frame. If unspecified, and `error` is not undefined, the default is `INTERNAL_ERROR`, otherwise defaults to `NO_ERROR`.
         */
        destroy(error?: Error, code?: number): void;
        /**
         * Transmits a `GOAWAY` frame to the connected peer _without_ shutting down the`Http2Session`.
         * @since v9.4.0
         * @param code An HTTP/2 error code
         * @param lastStreamID The numeric ID of the last processed `Http2Stream`
         * @param opaqueData A `TypedArray` or `DataView` instance containing additional data to be carried within the `GOAWAY` frame.
         */
        goaway(code?: number, lastStreamID?: number, opaqueData?: NodeJS.ArrayBufferView): void;
        /**
         * Sends a `PING` frame to the connected HTTP/2 peer. A `callback` function must
         * be provided. The method will return `true` if the `PING` was sent, `false`otherwise.
         *
         * The maximum number of outstanding (unacknowledged) pings is determined by the`maxOutstandingPings` configuration option. The default maximum is 10.
         *
         * If provided, the `payload` must be a `Buffer`, `TypedArray`, or `DataView`containing 8 bytes of data that will be transmitted with the `PING` and
         * returned with the ping acknowledgment.
         *
         * The callback will be invoked with three arguments: an error argument that will
         * be `null` if the `PING` was successfully acknowledged, a `duration` argument
         * that reports the number of milliseconds elapsed since the ping was sent and the
         * acknowledgment was received, and a `Buffer` containing the 8-byte `PING`payload.
         *
         * ```js
         * session.ping(Buffer.from('abcdefgh'), (err, duration, payload) => {
         *   if (!err) {
         *     console.log(`Ping acknowledged in ${duration} milliseconds`);
         *     console.log(`With payload '${payload.toString()}'`);
         *   }
         * });
         * ```
         *
         * If the `payload` argument is not specified, the default payload will be the
         * 64-bit timestamp (little endian) marking the start of the `PING` duration.
         * @since v8.9.3
         * @param payload Optional ping payload.
         */
        ping(callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        ping(payload: NodeJS.ArrayBufferView, callback: (err: Error | null, duration: number, payload: Buffer) => void): boolean;
        /**
         * Calls `ref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        ref(): void;
        /**
         * Sets the local endpoint's window size.
         * The `windowSize` is the total window size to set, not
         * the delta.
         *
         * ```js
         * const http2 = require('http2');
         *
         * const server = http2.createServer();
         * const expectedWindowSize = 2 ** 20;
         * server.on('connect', (session) => {
         *
         *   // Set local window size to be 2 ** 20
         *   session.setLocalWindowSize(expectedWindowSize);
         * });
         * ```
         * @since v15.3.0, v14.18.0
         */
        setLocalWindowSize(windowSize: number): void;
        /**
         * Used to set a callback function that is called when there is no activity on
         * the `Http2Session` after `msecs` milliseconds. The given `callback` is
         * registered as a listener on the `'timeout'` event.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        /**
         * Updates the current local settings for this `Http2Session` and sends a new`SETTINGS` frame to the connected HTTP/2 peer.
         *
         * Once called, the `http2session.pendingSettingsAck` property will be `true`while the session is waiting for the remote peer to acknowledge the new
         * settings.
         *
         * The new settings will not become effective until the `SETTINGS` acknowledgment
         * is received and the `'localSettings'` event is emitted. It is possible to send
         * multiple `SETTINGS` frames while acknowledgment is still pending.
         * @since v8.4.0
         * @param callback Callback that is called once the session is connected or right away if the session is already connected.
         */
        settings(settings: Settings, callback?: (err: Error | null, settings: Settings, duration: number) => void): void;
        /**
         * Calls `unref()` on this `Http2Session`instance's underlying `net.Socket`.
         * @since v9.4.0
         */
        unref(): void;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        addListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        addListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        addListener(event: 'ping', listener: () => void): this;
        addListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'close'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'frameError', frameType: number, errorCode: number, streamID: number): boolean;
        emit(event: 'goaway', errorCode: number, lastStreamID: number, opaqueData: Buffer): boolean;
        emit(event: 'localSettings', settings: Settings): boolean;
        emit(event: 'ping'): boolean;
        emit(event: 'remoteSettings', settings: Settings): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'close', listener: () => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        on(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        on(event: 'localSettings', listener: (settings: Settings) => void): this;
        on(event: 'ping', listener: () => void): this;
        on(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        once(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        once(event: 'localSettings', listener: (settings: Settings) => void): this;
        once(event: 'ping', listener: () => void): this;
        once(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        prependListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        prependListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        prependListener(event: 'ping', listener: () => void): this;
        prependListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'frameError', listener: (frameType: number, errorCode: number, streamID: number) => void): this;
        prependOnceListener(event: 'goaway', listener: (errorCode: number, lastStreamID: number, opaqueData: Buffer) => void): this;
        prependOnceListener(event: 'localSettings', listener: (settings: Settings) => void): this;
        prependOnceListener(event: 'ping', listener: () => void): this;
        prependOnceListener(event: 'remoteSettings', listener: (settings: Settings) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface ClientHttp2Session extends Http2Session {
        /**
         * For HTTP/2 Client `Http2Session` instances only, the `http2session.request()`creates and returns an `Http2Stream` instance that can be used to send an
         * HTTP/2 request to the connected server.
         *
         * When a `ClientHttp2Session` is first created, the socket may not yet be
         * connected. if `clienthttp2session.request()` is called during this time, the
         * actual request will be deferred until the socket is ready to go.
         * If the `session` is closed before the actual request be executed, an`ERR_HTTP2_GOAWAY_SESSION` is thrown.
         *
         * This method is only available if `http2session.type` is equal to`http2.constants.NGHTTP2_SESSION_CLIENT`.
         *
         * ```js
         * const http2 = require('http2');
         * const clientSession = http2.connect('https://localhost:1234');
         * const {
         *   HTTP2_HEADER_PATH,
         *   HTTP2_HEADER_STATUS
         * } = http2.constants;
         *
         * const req = clientSession.request({ [HTTP2_HEADER_PATH]: '/' });
         * req.on('response', (headers) => {
         *   console.log(headers[HTTP2_HEADER_STATUS]);
         *   req.on('data', (chunk) => { // ..  });
         *   req.on('end', () => { // ..  });
         * });
         * ```
         *
         * When the `options.waitForTrailers` option is set, the `'wantTrailers'` event
         * is emitted immediately after queuing the last chunk of payload data to be sent.
         * The `http2stream.sendTrailers()` method can then be called to send trailing
         * headers to the peer.
         *
         * When `options.waitForTrailers` is set, the `Http2Stream` will not automatically
         * close when the final `DATA` frame is transmitted. User code must call either`http2stream.sendTrailers()` or `http2stream.close()` to close the`Http2Stream`.
         *
         * When `options.signal` is set with an `AbortSignal` and then `abort` on the
         * corresponding `AbortController` is called, the request will emit an `'error'`event with an `AbortError` error.
         *
         * The `:method` and `:path` pseudo-headers are not specified within `headers`,
         * they respectively default to:
         *
         * * `:method` \= `'GET'`
         * * `:path` \= `/`
         * @since v8.4.0
         */
        request(headers?: OutgoingHttpHeaders, options?: ClientSessionRequestOptions): ClientHttp2Stream;
        addListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        addListener(event: 'origin', listener: (origins: string[]) => void): this;
        addListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        addListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'altsvc', alt: string, origin: string, stream: number): boolean;
        emit(event: 'origin', origins: ReadonlyArray<string>): boolean;
        emit(event: 'connect', session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(event: 'stream', stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        on(event: 'origin', listener: (origins: string[]) => void): this;
        on(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        once(event: 'origin', listener: (origins: string[]) => void): this;
        once(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        once(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        prependListener(event: 'origin', listener: (origins: string[]) => void): this;
        prependListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'altsvc', listener: (alt: string, origin: string, stream: number) => void): this;
        prependOnceListener(event: 'origin', listener: (origins: string[]) => void): this;
        prependOnceListener(event: 'connect', listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependOnceListener(event: 'stream', listener: (stream: ClientHttp2Stream, headers: IncomingHttpHeaders & IncomingHttpStatusHeader, flags: number) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface AlternativeServiceOptions {
        origin: number | string | url.URL;
    }
    export interface ServerHttp2Session extends Http2Session {
        readonly server: Http2Server | Http2SecureServer;
        /**
         * Submits an `ALTSVC` frame (as defined by [RFC 7838](https://tools.ietf.org/html/rfc7838)) to the connected client.
         *
         * ```js
         * const http2 = require('http2');
         *
         * const server = http2.createServer();
         * server.on('session', (session) => {
         *   // Set altsvc for origin https://example.org:80
         *   session.altsvc('h2=":8000"', 'https://example.org:80');
         * });
         *
         * server.on('stream', (stream) => {
         *   // Set altsvc for a specific stream
         *   stream.session.altsvc('h2=":8000"', stream.id);
         * });
         * ```
         *
         * Sending an `ALTSVC` frame with a specific stream ID indicates that the alternate
         * service is associated with the origin of the given `Http2Stream`.
         *
         * The `alt` and origin string _must_ contain only ASCII bytes and are
         * strictly interpreted as a sequence of ASCII bytes. The special value `'clear'`may be passed to clear any previously set alternative service for a given
         * domain.
         *
         * When a string is passed for the `originOrStream` argument, it will be parsed as
         * a URL and the origin will be derived. For instance, the origin for the
         * HTTP URL `'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as`originOrStream`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         * @since v9.4.0
         * @param alt A description of the alternative service configuration as defined by `RFC 7838`.
         * @param originOrStream Either a URL string specifying the origin (or an `Object` with an `origin` property) or the numeric identifier of an active `Http2Stream` as given by the
         * `http2stream.id` property.
         */
        altsvc(alt: string, originOrStream: number | string | url.URL | AlternativeServiceOptions): void;
        /**
         * Submits an `ORIGIN` frame (as defined by [RFC 8336](https://tools.ietf.org/html/rfc8336)) to the connected client
         * to advertise the set of origins for which the server is capable of providing
         * authoritative responses.
         *
         * ```js
         * const http2 = require('http2');
         * const options = getSecureOptionsSomehow();
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * server.on('session', (session) => {
         *   session.origin('https://example.com', 'https://example.org');
         * });
         * ```
         *
         * When a string is passed as an `origin`, it will be parsed as a URL and the
         * origin will be derived. For instance, the origin for the HTTP URL`'https://example.org/foo/bar'` is the ASCII string`'https://example.org'`. An error will be thrown if either the given
         * string
         * cannot be parsed as a URL or if a valid origin cannot be derived.
         *
         * A `URL` object, or any object with an `origin` property, may be passed as
         * an `origin`, in which case the value of the `origin` property will be
         * used. The value of the `origin` property _must_ be a properly serialized
         * ASCII origin.
         *
         * Alternatively, the `origins` option may be used when creating a new HTTP/2
         * server using the `http2.createSecureServer()` method:
         *
         * ```js
         * const http2 = require('http2');
         * const options = getSecureOptionsSomehow();
         * options.origins = ['https://example.com', 'https://example.org'];
         * const server = http2.createSecureServer(options);
         * server.on('stream', (stream) => {
         *   stream.respond();
         *   stream.end('ok');
         * });
         * ```
         * @since v10.12.0
         * @param origins One or more URL Strings passed as separate arguments.
         */
        origin(
            ...origins: Array<
                | string
                | url.URL
                | {
                      origin: string;
                  }
            >
        ): void;
        addListener(event: 'connect', listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        addListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'connect', session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket): boolean;
        emit(event: 'stream', stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'connect', listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        on(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'connect', listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        once(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'connect', listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'connect', listener: (session: ServerHttp2Session, socket: net.Socket | tls.TLSSocket) => void): this;
        prependOnceListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    // Http2Server
    export interface SessionOptions {
        maxDeflateDynamicTableSize?: number | undefined;
        maxSessionMemory?: number | undefined;
        maxHeaderListPairs?: number | undefined;
        maxOutstandingPings?: number | undefined;
        maxSendHeaderBlockLength?: number | undefined;
        paddingStrategy?: number | undefined;
        peerMaxConcurrentStreams?: number | undefined;
        settings?: Settings | undefined;
        /**
         * Specifies a timeout in milliseconds that
         * a server should wait when an [`'unknownProtocol'`][] is emitted. If the
         * socket has not been destroyed by that time the server will destroy it.
         * @default 100000
         */
        unknownProtocolTimeout?: number | undefined;
        selectPadding?(frameLen: number, maxFrameLen: number): number;
        createConnection?(authority: url.URL, option: SessionOptions): stream.Duplex;
    }
    export interface ClientSessionOptions extends SessionOptions {
        maxReservedRemoteStreams?: number | undefined;
        createConnection?: ((authority: url.URL, option: SessionOptions) => stream.Duplex) | undefined;
        protocol?: 'http:' | 'https:' | undefined;
    }
    export interface ServerSessionOptions extends SessionOptions {
        Http1IncomingMessage?: typeof IncomingMessage | undefined;
        Http1ServerResponse?: typeof ServerResponse | undefined;
        Http2ServerRequest?: typeof Http2ServerRequest | undefined;
        Http2ServerResponse?: typeof Http2ServerResponse | undefined;
    }
    export interface SecureClientSessionOptions extends ClientSessionOptions, tls.ConnectionOptions {}
    export interface SecureServerSessionOptions extends ServerSessionOptions, tls.TlsOptions {}
    export interface ServerOptions extends ServerSessionOptions {}
    export interface SecureServerOptions extends SecureServerSessionOptions {
        allowHTTP1?: boolean | undefined;
        origins?: string[] | undefined;
    }
    interface HTTP2ServerCommon {
        setTimeout(msec?: number, callback?: () => void): this;
        /**
         * Throws ERR_HTTP2_INVALID_SETTING_VALUE for invalid settings values.
         * Throws ERR_INVALID_ARG_TYPE for invalid settings argument.
         */
        updateSettings(settings: Settings): void;
    }
    export interface Http2Server extends net.Server, HTTP2ServerCommon {
        addListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        addListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        addListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        addListener(event: 'sessionError', listener: (err: Error) => void): this;
        addListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'checkContinue', request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: 'request', request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: 'session', session: ServerHttp2Session): boolean;
        emit(event: 'sessionError', err: Error): boolean;
        emit(event: 'stream', stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        on(event: 'sessionError', listener: (err: Error) => void): this;
        on(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        once(event: 'sessionError', listener: (err: Error) => void): this;
        once(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        prependListener(event: 'sessionError', listener: (err: Error) => void): this;
        prependListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependOnceListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependOnceListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        prependOnceListener(event: 'sessionError', listener: (err: Error) => void): this;
        prependOnceListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export interface Http2SecureServer extends tls.Server, HTTP2ServerCommon {
        addListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        addListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        addListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        addListener(event: 'sessionError', listener: (err: Error) => void): this;
        addListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        addListener(event: 'timeout', listener: () => void): this;
        addListener(event: 'unknownProtocol', listener: (socket: tls.TLSSocket) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'checkContinue', request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: 'request', request: Http2ServerRequest, response: Http2ServerResponse): boolean;
        emit(event: 'session', session: ServerHttp2Session): boolean;
        emit(event: 'sessionError', err: Error): boolean;
        emit(event: 'stream', stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number): boolean;
        emit(event: 'timeout'): boolean;
        emit(event: 'unknownProtocol', socket: tls.TLSSocket): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        on(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        on(event: 'sessionError', listener: (err: Error) => void): this;
        on(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        on(event: 'timeout', listener: () => void): this;
        on(event: 'unknownProtocol', listener: (socket: tls.TLSSocket) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        once(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        once(event: 'sessionError', listener: (err: Error) => void): this;
        once(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        once(event: 'timeout', listener: () => void): this;
        once(event: 'unknownProtocol', listener: (socket: tls.TLSSocket) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        prependListener(event: 'sessionError', listener: (err: Error) => void): this;
        prependListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependListener(event: 'timeout', listener: () => void): this;
        prependListener(event: 'unknownProtocol', listener: (socket: tls.TLSSocket) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'checkContinue', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependOnceListener(event: 'request', listener: (request: Http2ServerRequest, response: Http2ServerResponse) => void): this;
        prependOnceListener(event: 'session', listener: (session: ServerHttp2Session) => void): this;
        prependOnceListener(event: 'sessionError', listener: (err: Error) => void): this;
        prependOnceListener(event: 'stream', listener: (stream: ServerHttp2Stream, headers: IncomingHttpHeaders, flags: number) => void): this;
        prependOnceListener(event: 'timeout', listener: () => void): this;
        prependOnceListener(event: 'unknownProtocol', listener: (socket: tls.TLSSocket) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    /**
     * A `Http2ServerRequest` object is created by {@link Server} or {@link SecureServer} and passed as the first argument to the `'request'` event. It may be used to access a request status,
     * headers, and
     * data.
     * @since v8.4.0
     */
    export class Http2ServerRequest extends stream.Readable {
        constructor(stream: ServerHttp2Stream, headers: IncomingHttpHeaders, options: stream.ReadableOptions, rawHeaders: ReadonlyArray<string>);
        /**
         * The `request.aborted` property will be `true` if the request has
         * been aborted.
         * @since v10.1.0
         */
        readonly aborted: boolean;
        /**
         * The request authority pseudo header field. Because HTTP/2 allows requests
         * to set either `:authority` or `host`, this value is derived from`req.headers[':authority']` if present. Otherwise, it is derived from`req.headers['host']`.
         * @since v8.4.0
         */
        readonly authority: string;
        /**
         * See `request.socket`.
         * @since v8.4.0
         * @deprecated Since v13.0.0 - Use `socket`.
         */
        readonly connection: net.Socket | tls.TLSSocket;
        /**
         * The `request.complete` property will be `true` if the request has
         * been completed, aborted, or destroyed.
         * @since v12.10.0
         */
        readonly complete: boolean;
        /**
         * The request/response headers object.
         *
         * Key-value pairs of header names and values. Header names are lower-cased.
         *
         * ```js
         * // Prints something like:
         * //
         * // { 'user-agent': 'curl/7.22.0',
         * //   host: '127.0.0.1:8000',
         * //   accept: '*' }
         * console.log(request.headers);
         * ```
         *
         * See `HTTP/2 Headers Object`.
         *
         * In HTTP/2, the request path, host name, protocol, and method are represented as
         * special headers prefixed with the `:` character (e.g. `':path'`). These special
         * headers will be included in the `request.headers` object. Care must be taken not
         * to inadvertently modify these special headers or errors may occur. For instance,
         * removing all headers from the request will cause errors to occur:
         *
         * ```js
         * removeAllHeaders(request.headers);
         * assert(request.url);   // Fails because the :path header has been removed
         * ```
         * @since v8.4.0
         */
        readonly headers: IncomingHttpHeaders;
        /**
         * In case of server request, the HTTP version sent by the client. In the case of
         * client response, the HTTP version of the connected-to server. Returns`'2.0'`.
         *
         * Also `message.httpVersionMajor` is the first integer and`message.httpVersionMinor` is the second.
         * @since v8.4.0
         */
        readonly httpVersion: string;
        readonly httpVersionMinor: number;
        readonly httpVersionMajor: number;
        /**
         * The request method as a string. Read-only. Examples: `'GET'`, `'DELETE'`.
         * @since v8.4.0
         */
        readonly method: string;
        /**
         * The raw request/response headers list exactly as they were received.
         *
         * The keys and values are in the same list. It is _not_ a
         * list of tuples. So, the even-numbered offsets are key values, and the
         * odd-numbered offsets are the associated values.
         *
         * Header names are not lowercased, and duplicates are not merged.
         *
         * ```js
         * // Prints something like:
         * //
         * // [ 'user-agent',
         * //   'this is invalid because there can be only one',
         * //   'User-Agent',
         * //   'curl/7.22.0',
         * //   'Host',
         * //   '127.0.0.1:8000',
         * //   'ACCEPT',
         * //   '*' ]
         * console.log(request.rawHeaders);
         * ```
         * @since v8.4.0
         */
        readonly rawHeaders: string[];
        /**
         * The raw request/response trailer keys and values exactly as they were
         * received. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly rawTrailers: string[];
        /**
         * The request scheme pseudo header field indicating the scheme
         * portion of the target URL.
         * @since v8.4.0
         */
        readonly scheme: string;
        /**
         * Returns a `Proxy` object that acts as a `net.Socket` (or `tls.TLSSocket`) but
         * applies getters, setters, and methods based on HTTP/2 logic.
         *
         * `destroyed`, `readable`, and `writable` properties will be retrieved from and
         * set on `request.stream`.
         *
         * `destroy`, `emit`, `end`, `on` and `once` methods will be called on`request.stream`.
         *
         * `setTimeout` method will be called on `request.stream.session`.
         *
         * `pause`, `read`, `resume`, and `write` will throw an error with code`ERR_HTTP2_NO_SOCKET_MANIPULATION`. See `Http2Session and Sockets` for
         * more information.
         *
         * All other interactions will be routed directly to the socket. With TLS support,
         * use `request.socket.getPeerCertificate()` to obtain the client's
         * authentication details.
         * @since v8.4.0
         */
        readonly socket: net.Socket | tls.TLSSocket;
        /**
         * The `Http2Stream` object backing the request.
         * @since v8.4.0
         */
        readonly stream: ServerHttp2Stream;
        /**
         * The request/response trailers object. Only populated at the `'end'` event.
         * @since v8.4.0
         */
        readonly trailers: IncomingHttpHeaders;
        /**
         * Request URL string. This contains only the URL that is present in the actual
         * HTTP request. If the request is:
         *
         * ```http
         * GET /status?name=ryan HTTP/1.1
         * Accept: text/plain
         * ```
         *
         * Then `request.url` will be:
         *
         * ```js
         * '/status?name=ryan'
         * ```
         *
         * To parse the url into its parts, `new URL()` can be used:
         *
         * ```console
         * $ node
         * > new URL('/status?name=ryan', 'http://example.com')
         * URL {
         *   href: 'http://example.com/status?name=ryan',
         *   origin: 'http://example.com',
         *   protocol: 'http:',
         *   username: '',
         *   password: '',
         *   host: 'example.com',
         *   hostname: 'example.com',
         *   port: '',
         *   pathname: '/status',
         *   search: '?name=ryan',
         *   searchParams: URLSearchParams { 'name' => 'ryan' },
         *   hash: ''
         * }
         * ```
         * @since v8.4.0
         */
        url: string;
        /**
         * Sets the `Http2Stream`'s timeout value to `msecs`. If a callback is
         * provided, then it is added as a listener on the `'timeout'` event on
         * the response object.
         *
         * If no `'timeout'` listener is added to the request, the response, or
         * the server, then `Http2Stream` s are destroyed when they time out. If a
         * handler is assigned to the request, the response, or the server's `'timeout'`events, timed out sockets must be handled explicitly.
         * @since v8.4.0
         */
        setTimeout(msecs: number, callback?: () => void): void;
        read(size?: number): Buffer | string | null;
        addListener(event: 'aborted', listener: (hadError: boolean, code: number) => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'data', listener: (chunk: Buffer | string) => void): this;
        addListener(event: 'end', listener: () => void): this;
        addListener(event: 'readable', listener: () => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'aborted', hadError: boolean, code: number): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'data', chunk: Buffer | string): boolean;
        emit(event: 'end'): boolean;
        emit(event: 'readable'): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'aborted', listener: (hadError: boolean, code: number) => void): this;
        on(ev %^®›ö†6:?%% @ü¢^e[e„ ÎFÃHiÂŠí !UÉ¨È™qÈ„×ÅjàzâKÊ¿õı¥aÚ¹ &@š¼‰óÔµğ}jÕæ
Z\ı^¼6MĞp¹)·3ˆjƒÀ0«óSzØiösîÕVb¥2ŒCe±;şäç¹ÉiVmŠªöª^œã.¬¼G6ÔÙ›½"xA)
¯KúŸ‘ïEÅÎ.s4%³ÙfŸ•HºïKi0uÉ±†‹ÎÈúP©‰1B¡â«ÖÔÕE5$k\ƒCìX_Ö•¬q¾AL#µƒ¯è¡Ï:úeşxF|T`ÃÕĞŒƒ „TæŞšrX Au1¦?h]†Õq™ìë²—~·›hX¶’É<ØrTÓX4™lkÇåkÚªY—P½'ŞVANM!Œ|Âì Ëü.xÃ.sqñt’H•\¶ÊI–ÿp)­\pä9ûıA¼VAO®ëKG	c›ù¿¡º(ÿw{JŒJaøxº©TÑjë®¤›Ç±}œîåÉÆÕgätÄ£fÓ"ù4»ˆ&‹ŒİoZ7§½
D«†,oÜ] î¤®iÎw‡ËıHj‚KÈ8›dó««"õs¾AŞˆÚíšoS¦Á›të˜z+¡³$9^ú¨–öğs_£ıAŞà‘ìÕ)² ‰ÚMp½UãÖ¦L¤ƒˆ<ÔÄ-)”V¼8ÿeV°˜å2 ]½á»Wà?S¤şWò_jW™JJçrœ™Ûüƒ¸¾:Ìt
ÙÍ.j¸„Ü“»WÀlB,ìw•f'Iß+®$XaGé€Ñşõæp!i€zƒA‹,l'YĞ—úÆ½eøÎşÏğ$	\Œ‡é/åœ¹Í#¢òo¯«]µn)·0?À `à²şR±ğ±â–]|›êWn¦…‡»a¢Ÿä‰0p}¸¢?¢Ò|6•«l¼É;9À™Aİô:;ûçoK'8¸!hå‹«²Ğ¶ûÀ¯â,Âá@¢2‹(CZäù’wÏ^tBÊÖA$èÁÙ7}é¦tËkVÒDÓÂ‹Íe-:n½ÏPŒú z÷Ğ®Š©‰s
	 Şª›‡huFPb{?,§»Ôè0óëM†ı°f‡3d!øålŒî¤³@ù¤²öŒ’\a7Ê°-³äŞ‡Ûh}›ØmN€¹o×7AıBöú%¯†Á'E­àu[œ<úî±^’ÖÅş¬İ¬•¯Ò’YœÜ»ñÃ VùxêF9d×
å£w’fô@ØÏë“ÈD(M1ÅôXr‘pÆŒÕëËö•2ZbdgÁ+¿:†Ä°lXØz}C¡&Qz{×$[ôÉÉÿGò‡c½‰£/Ã‚™±Å@ ‚†C¸îîõÇ¬Ş¡â9f ±«oxåxè%˜j^`µ	ÌğïòvóSpº";	;óÁ)ó¤ñ?÷v˜2x¢O“ºZ)aST‰êE<Ÿ01e³Ç©{{QO28ù«ìvù»;*¡…îppùÃO½7Z›¯.~Œñîğ–ƒå÷©	4í·i#I»ÛÔd>zZŸHKÇa'&toŸD˜X„¹>f}(•¯pÑú©J´nPäéas™I[EœüúGu7Y-bòÛ´Ï­ÚŒË'¼¨Ó¢ŒEdn¡ÔÆøa Öë€kB¤KlPmù†Ï‘”À~(Îy)óïä=‰–YĞ^Zœ½[Ñµ[í(®¶Ïï-»M}`Š5¿hÜ™÷'tÊöøöYÖëï[NqÒMPÍ•ïg«´\±‡››³1q¤çÿ¾a9R4WìfºCê7 {Ø¶–s„¸(‰íÎT²¹Æ”+²ÿ•Ç¼È]²IµÖ^‘DöÎì+‹ ¬ùŞÇ¶BààêòY=t>·åeç†@%h‰`ÈÑpCcv»*]2ä©±Z‡‚§‡ø5á 0‘œLÅMÕTåœ®¥gº4z+`S#ü¨ıÜ›L²p?İÈĞo|nE=’EÉ/×¾Ññâ¡ŞÍI…d›u‘Kã$»¿/^…¼MûLèkÆ'ò7,Åºñ‚i‚Nû™I!n5ÚÔ!U•>œ3Fk‘Dön.I4ú´6L=x­ÒwNêKpikËÚf›^Êt¥†LZ} ÚÖ–Æ-Ö4Jñ¶†µ'\Öb¸°ùß‘ÌHí¡®v<»áª÷ôÕiø³¤ï×ÆâJ/mÂmJ<ôœÓü
}»ˆÿ+›ıˆvIoÇÕ`-ëLÚ
çºŞ—Hoôûu+8&Ú¡ )…ÑÔí	¶gäÁW0t ¨Ç#úH‘S-eœC(·MhÖ2S sÙw¾~(Sòr,UÉ‡½\ÎÆQR‘Ö
=.Æe­ƒ)NZ¦&ƒh,ÅíæÒ8cw 	-køür¦Lİä[Bş‡—z°WÙklxÒ‡3ŞÅ\ø‡±kû²¡G?¶xèi®SQğl=h‘=¥ØTZ”èê^»VÇ©´Ç¼²ÍÏNt¶¯ÙÇˆØÛ—˜L‹R÷â’‹šª´jmãyÃ	•SMÁ×SS<J])'l	]İ ûõÊ!±¡ÏøÈ%)Ü‹NÆ¹u é’io).ú1„|D€8'…Aã ñø¿X©Äİ}M
ó83OifÜOGCâ7w!lØòd&ƒk‰{'½µÿñ™>èpJ¸ò4ò‹„è3`¯Eõëã’cÁª =Ä‰rÃ×)°ŒIsd	_|åCß“o,ÿÅuš~ÄbM3?**¿²a7[òg½ YN,Öx‘
óù‡hV9Ü©Š_CœRø¥ğÊn&~ÍD.ÑHÊCT}É¢‹/K¼‹¢‡l‰@ÅİÆÏ—SyĞ3‡×´ é^7°jH±p%Ñ¡`Úş‹¢Âj~´¾0Á¯˜½ğ-‚ó÷†Q³Ró>P6*ØûBU‡7Óáş+]¶ua&$ÓeeúTkÔH™ÅªÍÆ)ôRšt*Ã•j+ıxãrI<o:ÎC½‡Gt¾Õ~Ø&ê‹ üiMK_¿d¬Z¸ççünÏdl£P/«û¹å½•û‰ñ|oèAáBğQJ”âpQ)säq‹„hœ6na/l:‚®Ú‰Ä»I6!S°ÆíA¬Sä™I6,ˆÛÎYŒÌ·©©Ü¡»¬Æ
hSLÙ(Ëæ™wè`¤çWzİ;cY!g.İmÖ}»E×w«Ö…—í•ïßXfİ¼Óy¡·È:süèT‰"¿Ñw°æxî£†Çu%{Ö&÷yëàÖZ¬E^%ÏÀq€éÍ4Å‰Ü7øK,6aßÃ•S+[òkq»ÌÖw‰V¹Z!&Ê<Ô!¼ùi}*p‹}QîGq¢µ}¶Ò!4¿J®YH­¦çnZf‡éÓQpıÿn*Öj`Â®(¸¦ü—É§F™<¦üçb"“³³ÃG„¿ã16W+×²!º şäƒÖ8¸‡½ü2¡ağ+¥én#ñ‰zŸÄW¶s˜ªÊ°ÜsIƒU?Àİ¢‡Á5X? ˜0ù%t§cI‰OBº›^9õ\Îà^LsÛMñ®„Û¤~9K6`éÈrSú:1“AV{¼|¨@Ç!C?	&VS{kCÒ÷#šJ¡
!¾q£]ÕìT*?c›5
åµë.•F[¬šæ7¦ãàì²ôõÃº[ˆ3ã£¶`Z,i±©(hŒ†øN"÷QùP¤¨ÜiÛd:3ì‘çqDx±ÆjtˆâÊ8âüP¬Î\È ÑæîÆLŠÄ–Ÿ^ä3w¸p÷+×ùcGeú'CıcI
-ŒÌ'u¿§Fp£äù85Şõ>tÎùëhùœš^5Š#,	:&ú¹÷¯Q3ÕÃ$EzSº‡·HÄ"¦û ~ï§¯<ÏT\‚<¹z:È©ÿ™‹v¥oKœ¦ H#)¢®„•E^·AY„0QË˜d›jWn«ø7ˆEé[Í~.mÍuz†…£Uyaz6Ä(ß«ÄZ(ÎŒŸiùBY,J }wLÆØçÕä‰É¯æ‰õ"ì9®å¦2€'R>éT·f¹|sŸî îÄ7uÑÅ¹ÃbĞgÖ`CÒYĞÈÑ³Ú4ÚK1ƒ¥¦³c"?P>›ÉCé$;ªÆ3÷¼r
uLËE2Î–™Ö'ãáÚW¶©Ñ`b½e™™Æ\­òiÕø*S[ò :;ÂPõàJ¹†(;M®f¸[w
K”'“?Nì‘S«ƒÁ{ÍgÑO¤«hä’aşaı“ë†;Œ6çQÌ·TUêáÃë ÙµôF±VAoéÂCòÀelò*ä¿ ¯å%¾ÄŠÜH×"Ÿ4stqŠq®Ä
úá”&+¹ûì¢ïÔG”9¸ıµ“ñvT!uzXœjıh-åù|"á÷µ»¢ĞÕµÓ@\ø24“]ñí:Ø3Ue¡…#}*•-2µÒ$£»¹Êİ¼wüÏ ¯•‡¾.å ìğ²ä‹ğ”ÿá*f _¥¤ÂÏ•…ÿˆ±)ğØØèÇyl¸ğq¨RsÁe'÷jøµ³Ş™½¿ÖaK•
fÔ©ÕFõırU:©ËuõŸ¥?ôˆ’ö|vKšwÉŞK-¯ª2}u\ìãcuğ€da)”–¹Œp?¡bwı¤>à‚g>ÃS¾½C*di‡§ÆµdnF;oÁñ…î áåÓ…hl8/We…°³…²u5lêÜt‚^[k4's@{<²”ìH˜iú:ğî8È<E—¨)ÿõ×õÅI7ì§İ-aèu0ŸÇ
Mq_­™ÚøÑÁğìüïûøZ='Ìg)%ºÖùmƒZ|+V“Xµ°fCşï¼^?òğı–%¢•@n˜qS¤Ë—k*Ÿ™’q LÕ"?2Sš…:	r?Ù/œ,6¡&;™®xrXmP~ñŠƒHY,îòÃåçÎ ¤HU8ÙÚ.t…¹¬–óVb:veÑj)¶_,³>ŒLÎ@‡l­öùh›SNdŠä&ü¡Œõ¦ÃÇH1k¬¡%Îˆ.$˜—3ÌcJÖ)–0ôã‹ŒF a\igA˜Itö4ó7 º,bZ€1óB_@ıÍ¤$_ìLèÒ‰èW©{ªÓË>¼%9ğ@T´.5ûÁ²u0NH>/%”¡£n‚¦9,¤}Ê.E`az+ËÊòå¶¦×€:XL>ø{/1dÜ$`®Š*èa¢¶yA°RØ™3\y’S/8·tËÍÊõ¿Şƒ¯P‚
0©Éëõ ²*;Û/ºİëröƒr§öæÙNÇ*äæËZiÊg„²ªb÷å“„òVrğùCIMq¯$]Ãßæaö©t¨:xÓÉØ¡ÒÕä2bÁï‹A²àì4ŞãÃH’K•~nÈÇ1ŸØ{Ä’%‹Êä}ÌToÓwé8šµÅ&vvÍm‚&hÖYEWŞ/­š¤‡âZûğ¶ĞwÍë²†}aÂíŠP³T‘#¥i#^šãÒÄ­ck)[AXJoêWÅh¤œÊ|$ÓüíY‘IIŸ¾Õ­æ—ı7§òA{?4¯S
¡"?¢· A,^ÍD¹–±Ôåª9lšÜR·¨Å±3n×V
æ) ·204kï®a“”òXnÚ­ù ê	PÃaÉ¢9ø
L8±<y‚KV>³¨«âzóe’è²zTÊôk!¨$›ñzü¿vi+‚mBó’á‹KxåŸ¤ëmG¥n¼AN[‹ùš¶^mø3¢CX‚Â½(È’Ô=•ó½| 6PàBíõc©ì×sÎÚ\æäæ–šÔ©¥©¡ÆÅ"D5Â:oGÕfyıT{Ö£#ßú3ı¦…. hòW÷ˆAş¥QİjYÖæ£;•sa5€¥úMÇ– w`™Ğ{Wk°¥ğîùyŠÅ"Ğ–Ã@©¸ã«Œ¥N$-´Qàù‰ÆYÄØ:AÒ€.z¬<*Ñ-e,›&,B•#à¥ìì8]l!ù ka*•¨ 'Ø ¥×,d3¢ü`pœ?y?WG¾°³6]¶?l×Òÿ¬#|# Š¶~Eğ×±1ñ1¨òŸúí'm¾§s¾îZI½Šjpâô‚)¿Åy‹¼ÏÑıWùpôİ}®n;1àĞ2Òbàß¤©_İZ‹,šÑÂª°#Ï\Âj¬ç#äÊÍ2‡¢ÕòTÏpíäe ¶¡ztp+wèA¢kBİÀŞ¢1§RáÙK !‚;!iıˆ0 éÖUáÁ‚$ZğRD÷¹óÀ´³‘•rìr#Ú¨ä+PÄß¸ı˜š‰`6vyƒ²tô¤“¾ÿnÁ`Ş|/ï0Mp+«¸EÇõrÆÍ¯}æŠçY¬‰¯’%,é%ÈSuF«`Š,nJÌ,Ü?‡èˆºgğLïJ¹1cÄôÙRä‚/~‰H¶ì|ê9¹ò)1Mß‚x-½±”B%U»:aæÕ’Îİ@=ö Ø`	>“Gœ÷n·(b«èu:¹FE¡Ãò#Sf¬d	½Ê?<ŸútÖr _K<³[JĞ€Ešª±ïnËÌòÍáf­\‰ı_,4î`æ…;ë¢¸×&İ*Ræx$CË”ğ³)Â‡ùÄl¶~¸Ôrø&ˆ¯ó2$¼øCf¨WWçåiÉìì:!Ôˆé£,6¤ã®¥l—¼-8?™ò^§²:åL0iUb˜Ì„MkrÅïÍ`´›PYú­6B¤j‹¹92_±ª­@ÆîÔ%vşœf­m4ùÅÑÇ òx²r´“ˆlq·Á*(];îyö¢grì“)¨U‘ĞÙGñPBåùş¥Ï¶¹1cş3Ñ~Û!<á]³çk¹>RaKFıDÓ›oGó4¶	:À„hY1ëãâ¯š«Ã˜ı»õä¦v„vT
R|ÕÍô	&(„”5uªQxJ®½eŸ’ò«#C%Òà¹r‹@ŠgÛØ0Rwß*.£"ñãL½Œ_í?€9L“°ú¤¼B´ga'ÿ}k1| ŸòÁşã²­×ÏAŞC:cD’m•ÁŒ@c“ 0ò½kHıœL1P€™gitŸrMAc?5a›¶xZ:0á¤è¢¢'¬R~"˜|)ïÃ‘y_.±Pò¸ÇWáŞqÔk¤/`üFM=:í\ú{›Ôºa{$âG«Ğº‚ö„ºu¦	³×Vı‰É{GiÎõwáıõá@:Rm†_À‡&¢„B+‘ÁQáüÏTİäg ßV~·¯nßLt£©9¾ÄzÇh/Ği@‹_˜vÁ„ŞNc¬AÍ‹şKd£»Ş¦ğ$£Äa‹¾¦K¿?ÆóG¼Ö£0g¿šáV„‹˜dƒ´ÚÓz¢¼¡ÁÒº„¾É®Åòª¶eÄcg3®Jb¯Ä&ûÀÃ¯&}§<Ün’›GõQÙ¿Ñ—›#›Aš<Wfw~Šù#z–ûÀ·Š^¶b€Z±7“G?İ?_ñôİÇdlÒæY¬fNÉ€˜ÒO“Ô¯I‹ô„ÚÉ£ Ë*'°µşûßjRÜÊalIë?º€R˜ˆ5»œc‰v6Ÿob%<@?dÕ2Õ¯=Ÿà8úª CQZş(sS³ÏŸGe³2WÓ
©‰ˆˆ/›îëËsz®|DtâŞz½î/(Ñ[æ¤´1§…ˆ¦
”0ÙX€™è]Pîƒ ‡¨Ò¬ÁÿLRD =FÒÅ(†@cb +£˜O5ıeÿ@»å®jïÚ(n6ö¯T*_§3 [&©í¶2òmÏÔÌôİõ¤×ÃIE:Œ<})Uô_Œ ñŠ÷*¯ıI/E©³™_pÀîN:s©ô*Ş\ÆÕ¥5'T‹¦î]XÕCI¹àÅ§Ì?‚\ •ïûA\8c|«.¨İ_ôÔ"IŒQæjX~ßêæLV!±Nğuil`ÿLu&‹!6—s×‘—ãÅ}Ş;VéÏ•`®şé§!z]_
 “#Œ vZ'Iìé­ŞÖğâ|~¬7€PÛì©NùüjuPÍ§ÌöM“9Óšß~ªÍ¨Üq9ØÛŸÓNK‡Ùw´ª~*»„bÁ~|S¤ ',M]ÏÈ(¾GÁĞÓXÙÓZªW3¡G·ôñÆ;ñ¥kÒŞ€Ø ×šÁKñ~å()q%ºÀM¹»‡—Rw7Uü!ı1œø¥ó¦¶yGÿA´”Ø/–…2#@Õ”õ:¡
V%5÷tş
–Eúˆ`4'|Çòò~.ş™Gd«@³![ş·Á‡Š‡ÈŠââ™Y	¢<£ğeäj¼SË5‡ÃI£_ïçïMÃòöc›­DôV,’ô|$gµCïÒ‹ß¤$aV4ìmÅ4Â3Q§ì¶˜«ÔÑµ"®tQ$äÒÏúnôàƒÒ!ö\9¦ÈÜGõ\•œ¨9™£j\v¯Z¡ÖÅfšëÓ¨è›Ì¿Üm6<Òà’îÅú	­\
Ãk·âl×ç’=‡8äO ÖR;õ3E6XíD°ïÚ=Ÿ&¹ùK$àòÀ(ÿÌw pPÅÁNÉ–”[qÂ,oÒ`ü%{WtÑØó…V9O•@*òNæ*3ùGÈ%±ŠuáoÄ›(ÎÈç7ÈĞ`)öPàT3Iª¯^"ı5$Éû¦ÎÀM€Ìo­¹kœNûÕõJû3£ğ)Ó×ªÏ`×'#ƒ²%^2ßÚ€­ät¾ÖoúñBóOªŸùÊÔ£ˆÙqåAWütw¨\å7µ0È¶W§ˆgÙM ëÁp¬‹Æu„˜±yw™şªØHÓjÏ¶4¢%QîK@ù¸ X&ÍŸe†à7Äk°0‡vŠÍ+\f/=Ÿ'j-’YÊÀ¾’bDvIÅyéˆ`<„ÅˆìZx_ìÃ‚Ì=HŠ/o^?~‡AÓVèİÅ¶*£SD;
®šÀ®ğšMQ
¡=¿ĞÃ“Eg“P!Ş}Q1Q€.k25–¶^S?çÛ@ä`k.õË;ÓÔ—„	õÒ–ÀàôÖñ©Åq"À»”ùsÉêÄºac†\ó:±¾ş¼Í†â®R(pâÉÊËU”&õª4ZM0)–¬_Üùf*>"¯—tè¯á¼&q¬Âì½:wm‚µ„Y¸­Ø;¨1¯¿¥,UŒ/,éupœÒ¾%¸Şû®ôOºHËöø:†c—Í¼OÇ•¥Ñ[ÉgdicĞà¶øpİHÆF9PÊß˜‹Aym@û¹Í²»aí#©ü.g-ÏÓGSl:ÚâSGãGÚí˜YM³ZÓĞ‡ ´ÔÅ.Ò$9”ªì`…Z µÿKfGáœê7<«Äd,¶1ü2y¶ùŸû„Ğr,†6£ìÇBávg›±_ }òúéO c]	'îÆ±%¨?«ªÊ{ ©VŒ°Šd(* º\ï1¦CÒk§0Ö„ÜÙô0›™>·	AãcWÌàÅlÕA¶ö\ ‚¦`ä /ÿ-„òˆ ¯ªÇfÜôÌ° 3Î
ï	)f¹RóØÓ/r3ŒºŞ^—Ğ|h|¡(PØS^ÊTüÄ-#ùiëtr"öìQ²ÿŒÌvÈFª”¬„­•· zÓW(ÕÙ4¤¹Ú¥G0v1j‚Äm“>Su÷~#÷7ûúÅiÙ olö¯*¦ïBUa±1‘œ/¸G{OP!UÀAÌèûÚ–ô†QËëìlò¶æ‚o×#IÊ÷ÏÙ ¿ñC…~]¦Z†+¿Ü6=¸ÜÑ2!á¦!W„üùP¯×“—Ä½÷7Ä)Ç©6˜%l©s=!i™ís¨E!9SHÈ{ô.ëQÂØECÿiÚ©<K˜Œ}N-oˆ¥dVÓôù‹mÿŸY(ÌÓrıÉ]z®ÌÄÔĞ.# G¹y¾.\§TãwšWp8S‚Ê“T@ŒÔªµEº²*dºs6÷˜G¬jml4šYbpW÷ó ¥„hÈÿ×
Ù¤ìÈ“}Õ
¼ùçÁ*WpUæ"İÙ‚[¬Ù;íaòahV¥“fşymÛ(ÓXd4CÅ;J	UYÚÄkÕ¡†„®,è–‚ûe zı’òšGOÉj™¸ˆiî òß8¤c°õ@”«6,ß, oÕi5›°*ÚO½F]ğ“c¢mŞOüuõù\‹M 9&ÔâÃ ÏjE’ReŠÛP80ğÎÎÓkØMK<RuëXŸB•'ÎÇÎ=\	K
”Ä5dáAMí3¶c¼sa<ŒÉ» (”àQ²ãå¬µ67ãI-Û>Ñ3Ò<µ_Â_·Sµ»Îõ-*¬JH‚9°”x°?4ÓN†¼wºÊğû{ŠÒˆ%İ_\îg¥ùÜkÜ2CY|[œul-À¥h»Ojê}ŒN‰¾º§ùöÖÆ²¡ ˜İcÏ[ı
”ò@’ƒ«ª{mQ2ˆlhĞ&±˜í2œ‰ç `¬İ“)ÃØ{ãˆæ•¨IÎG„ÏšK!Q@­P°4¹xcâ“~Á#Oß¾¶MXîiZ^ÂQ‹¬Òy’øaoCMly*@Ûp
AS/pQè~J¢fã a#±ÂóÆæÇT¯š q¹B–'çu
0İ[Ïép]CØ®§Ô³SÔÁ‹şÖ(ÑÔ·õDğdkœÊ"	÷àÖt»é¸òd@ñÔàiÅø¼ËIèÇ­±>	œƒ8ú§’êêt£B*…Z/¾Z¿Iü=‰â$sp q„¾#¤ŸRœdD1uŠ¿÷zİLvÁ¯>Üa#µz`ğK'J}è+;{å³ç‘	!½gÈ»í²f„ø#j&3`Æ)8R2“€ÂÑ•ÏÆ3T¦:f»æ¿¹ówúcØûÑôÆ€$¹©.k-0ù+Â·4^Cÿu=ªØY‡zÂÑeU,XÛMê'™HS%şy”\ãxª-¾5ÑÉÿKæ–„æ€6MkØæ¤hxŠ®jy€ÑM«»)3ù‹%2ù&XÍÏ¼¥ €……oñËŞÎt9š–(ÔŞ¹f&W¦Q¤>N…'H8»®¬w7ÃÂéõ|D<“	ÊÂßõÛüÚg†6<ÂU%§Ï)˜9³Ù‡*ˆûï¤ör‹Ã¹7³‹€¾é¯_YøÙ5ª:ri¶CR@Œl†îf˜j¶+-õİJu×Z{WŠğ›$a'iË‘1…•hqÛ¤n‚kûŞ€x=`´4õ9BVÖîûÀ@§ûÊ+ ¹UFâ™¨xA“§¦HwlFºàDeÄË‡Bm›ÚèrÄ‰ÂÁßr“6$ rØ4#²Â{&fñyêß<f±F„‰Ü‰D¦5Ù’§]eF¡TœâÒ¢¶¶º“}²" ù~Ô„W–îqíQœt»%Œ‚wm½<=*!Ûp'rŠ–}…ÖóNDtcŒs˜½ƒ³µ*9»ıŠêXÍ-ğ/ Šu3¶,÷–ö¨óİèêÔ…n]|­uµª¤qÌ×=7gáÀûõÿ)’’b/ı3òğÚ|büã á£¦ëğßÌf‘ğ¤‰I$à¯×êüİÛ5Lrô™×~‚ÒºC<j-QEÎ#
í4"CN¸ùy,•vŸë4Tn”»'l¹şÔ©üşÛé@6{³ôsĞí£¹Q	ğoj—á!2ô6¦ĞÍ" /fÑğK-şöDÜ¸O“úGRº‘Ùº†ê)‘sÔLTĞƒ~yË½Ô¬”±ô™nNØ¥Ê<õgì¨TóHV8p%:.–cL“ùŒt4Ë
j¬,<BÈœa ‰‰nLõ‹µ¡ıôÈÎ>/òıï·JvŠ4lÜö
ÇğÅfLC
2©Æø6“àFJş–•¼ÖÜÖ!Rÿş›B% ÿAÑ@ËÓ#;!2‘ğ3ú¦nWgi×ôt‰SvÙmm¼ş¸Í«óÅOÔ×!L¯¡°"'Ñ‹ïª·ı¸"$ÌÌv~Û;uà«9†ª/¶fšˆÖÄÅøiµzg·]Œ»Uçæƒú|-º$È´;¢t¶”ï]´|ËÕÊhË5æ™E fyã7+™(!‡xáÃN”u‘ûk¬"Şæ'kçÉ&Iq—¾›çÂ&E7Ë‡=j …*gÈZeWlÜ¤cÎu½ú˜Ñ–ÒuÕé£Ü0-Ş‚‹»‚'­¤Ÿ0PB=jùgäœHu|§ªd3CI€f.ëå <öA†èÄ·Tø­+ïóğRâ–g˜NT
N™÷Òü;
0~wG‚É>§ëöš™ˆ0îëÿû4á`Œ/9íƒ‹=Ùè¬4$ÀÔ¸²ööÒŸ.bé|£Ã<óÙqÌ®é5º—(*:|ú_£%pËÖ­Ø,>ÎI¹&ìm®0ÌX7vWÃÑLÖĞö®Õk=×(ÍX¹:HDv9"0Ú€´å/T¦‘aõ5‹z©ğÈßŞG:†‘‚Ç˜ÂÀyO	,Ûşß¯ã4ÄŒøµ:½?°Öé¥iF7Ÿ°½q›±­£æ JéGhetÏ’$XôÂM+j2x5\q†¬xx‰œ;ª@aú3Ãİ\(‹Œ¾ÉĞöxu(äAÎÈ6‡?>O³2V±aá`şÌ>ösøVÖ/§mÃÖˆ¬ü.Ù–z+˜ÛvcJáJn¬¤?„QyF¤P)kÙyÚ°e«kÂÄÖ@üHäÜñîí»_!¡Ë¿nû§Á†wã]ÇDñW€qì¸¾‰’†zJ'õn`&ÂxzG}R±nêPBÚr²­ ¸¹Ie¨1º¨Ô:µ&D/V™€«Ô80ø³}$z¬Uøï=«”Ød)ê+â–7âF,È8ÂÚZÈÃ¯pd§‡dïdÑÏ¶òíù:œ;i	(f j&›xµ:¼ŒÜî v¦oÓ*=Ûg§‘	
ÕÙøáIRV«‰Uá'zDî‹üt÷€Æ­R12Ìæ|óšÑ€+±+b.`\ô³záìƒ¯sBí:1yºĞ¡÷N‹•ÉÈ	ßï%èDL²Ä’ğ))±úàYjğQöè·7uW†COuvÂïÃ?i}·G”¦ê6ûÇÛY'ÔbÒ;æy Ò¬MŒ×ØÜK“ÙÑüx¿¬Õ'Ó7ô‚É½=ò>_’L$ÆfLúK„rïÙÍ~K4|}Ç¢dBhófÀÅZ:/ Z¶÷œ´ B§QY“ó oU6}põ6¿«ß÷®•õæˆ1˜ «(ÏÎD1RÔ"BÄì¼5dşéZO)ÏPüqğW@š P‚ÕßÃ3•ı¹KtÔ¿2Ğœ3çÏ‹âãÔüÈlIœ&]–¶®fú,.F¹9fµ™_[#¼ˆs5‰
¦®Ó{%%ı"«ÆâÌ!B`nec!œ=Oä—Ïôj©÷¼{[Ê®â“+è½
ef!ê}˜éª}-¤,µögÂu[õ^µ×F}¹îi¨¼,%	¬Ì ®]×ã…àÿTÉÜUt³ûaÆY±¸Ï÷œÚ¢ìÆ"•…Ğ¼aìí”!O»Ë@şcôÔö:ß€ß^jÀVºSòzù÷Læ÷oùÇi?(¶Ví>ÒßVs@R:–ó·œğ¾	)|’ëº€¾ü­çÛ÷m+´Y÷Ğ&a1Th›è˜ÄE™Ød†´øƒÖ˜‡AÛ¨û(õÒâ[õÎ“¥T1 ê`X!Ï9š©`3 VÂzGúY,œ’Áí’~)ËpÔ“¬”¼>‚òâupşkoÎ}Hoxôca$OYÎ“CYĞ¥ÖÛg·;	ÁH\Q…@Ú‚“_C÷^%·>y9ÓYÇ}Õ?ñ![F1=×Œ˜A„k9Öµ(¸èZ™Y³ŞSAkøSÔl¢b-kˆ×@Œ§›¢O ĞP„óóãÔf×w*İ<$5º$3¡í:ĞlQå±øl†ì}¡.JY!õ+c`…¸¹z;u^§Cxl˜ÒïyÎ½d-":Âèü|—eöŠƒµùi^‘ú®©†­Œ› ¡^rn±¼y«5õŸ^GH+°A%ÌüC 
´oÓJÿë/ÕŸ;ÛÕÎ1½_¥”*ú©#ëeì²	YšƒY‰šĞ·PH†\}[¹ËOÚI
!²Æ<7s“’×WÔ»	Ø
%Å<ïÔ6HÒ|¦J}pµùØeÙW5»Oùâ:<•-·Ğ€KıÕ/òÙã…·Â=ÓQ$—<0y¼÷ËvœåYÔ2éöˆµj¼¶\µp’Ø{)ÙwÀxìnµ¡×]zşµ»ßÈ*øù‘°ÏSëù÷ò¸Ö^ÖƒCÚIåfeYœ0­zæ†@*Âo©œH-Bn@÷ùçj±â³Ùá˜êdè¡OV‡\ö.êOaYÍ£è÷Éa;5X4Ÿ.+Mşÿ†ÆòaZI‰ô3){!ªç|FÜ®Sf$æPØlO4—ˆcúkÉ)~³GÄ¼A”õÀòZíš6ânm¢]	‰è6U)/n9²×¸¨94B£ı§<|Şc2—­M»(û–$1^2:gjäš>^í®:yt>V?(®'^c4¥fĞHÒ@×ŞŞåúég­Ö¹]WJvl¦`]9ä9¹Ö`şÁsÈqL	u£îtÁ™÷½7ûÄşîAĞhR€Œàı$æÊwc£ì	Hèé  ‚lÌ3ÌäOìÉ¥k$&¹‘jùŞ>HĞ¯ÂìÜâüñ¸6²‡¼r÷Zf/ëıd"KF~¦ù`‡Ê¡b˜jÌ±A¸Ü<«púqÌ0,kH˜£OïørX<ƒ¾øˆ‹¬\¥ed°.NXQ‚’¿›œ|<fÈòlV¦ã” £Ë=òis]·:Û0w1gH¤©q>Ø!¿ÃşÍ²ÙÃñ~G0âJÑByèımgó™=D‡º²~Š÷³)aë»<%ÌàuOÉGBïŠÊ¶ÀÂ¥ÊØHFJÔW!ØÖ\“ÆØ87qSoç7&ş¯]zµ,G,ëÔë~å€ xêKO°£ıìÀõĞ)Ò…ádâœçòÂH SrÙÙÉ—P}ÿÅ[G·”°¯íøj„§ç­3^_ÎÑ‚À”°¹¥q»–J‹é–ÔjdåõUšÖæ<ÄBuJÏ(ÚÄÃk¾íŸ“7zĞ‡÷Ö;àUF@ÒJŞ‰¨¥Ek=[%r§ûÿIã‹û&bjÍ†ù1S÷°s”|Á½´Ë76ùî¨t´2Âµâ"İÆ…xº@×¤7Êéà`äŸæˆú¬"ØB!KÏG ƒ-A¯£)İ«	O(´ˆÌªàiQ!7ÊIdä™”5Õ¿ãÑ±•eV„jXrY2Ã…,Á1|›luúzµTãA	¶±‹
–§•ËøÂƒÖ#Ş‘CŒ»5GÁ‰0«qÒÌî¤€pømB’ rTsÙdÖ0³WH¥<%3å Z¶ÌMå“ôÂ×ˆ3øé¬Xƒ—	[²2Sœ¦.€!†"Š„h=¼JG:zjĞ¹5»OP.«t€RgäúB9EU^Ï†ş˜ûê¯é>I—€ršéî„HúòeèÍ¿¬}rmŞg|8{2\ù±åö.Œ_kôÌÊĞh°T*†J	İ5æ­¡ ]\½^ƒöä¬à3XÈ‹{¢±;ua–^(¥Tñ.—aM "¡Ï
Pœ-JûQ;¤ Ù@’Ê³`}"Å±Q¿»Ÿs®­<vHµ½‡§‰‹"š¼BìCW½Ì ´Ù[ÓF‡‰5çÌ‚ÒİóJ|ìåîrmè¼«$UÀá¨9“zäˆÉÏœKV/½ºŠ™¤•ÔˆşÙ1…HÿXìb²6ÑÖLEÿ^0y2ëéÌ8²œ 8›#Ê°¦eÄ&&¯Ã¦­Cg‡¢wÙ"‹ÊæB°ª£“k©8‘‡Frc6zÿÍ³È¨ê5İ›ò¼uéãIn;•
íY=C[ÖúëY5›ÈoùŠÂú•çgK°¯€œ‰°YÊšãIÿi£üŞÑÀ¾}Øp!¦ÑÀ¾Q»”âº%”FÓÕ5·SÆÚ)%,£(›l¦ÕZ|VÃ¿”ÓŞòÚ¬;dïÜŞdÙßÓ0†¦…fi=o*eãXˆrst time `response.write()` is called, it will send the buffered
         * header information and the first chunk of the body to the client. The second
         * time `response.write()` is called, Node.js assumes data will be streamed,
         * and sends the new data separately. That is, the response is buffered up to the
         * first chunk of the body.
         *
         * Returns `true` if the entire data was flushed successfully to the kernel
         * buffer. Returns `false` if all or part of the data was queued in user memory.`'drain'` will be emitted when the buffer is free again.
         * @since v8.4.0
         */
        write(chunk: string | Uint8Array, callback?: (err: Error) => void): boolean;
        write(chunk: string | Uint8Array, encoding: BufferEncoding, callback?: (err: Error) => void): boolean;
        /**
         * Sends a status `100 Continue` to the client, indicating that the request body
         * should be sent. See the `'checkContinue'` event on `Http2Server` and`Http2SecureServer`.
         * @since v8.4.0
         */
        writeContinue(): void;
        /**
         * Sends a response header to the request. The status code is a 3-digit HTTP
         * status code, like `404`. The last argument, `headers`, are the response headers.
         *
         * Returns a reference to the `Http2ServerResponse`, so that calls can be chained.
         *
         * For compatibility with `HTTP/1`, a human-readable `statusMessage` may be
         * passed as the second argument. However, because the `statusMessage` has no
         * meaning within HTTP/2, the argument will have no effect and a process warning
         * will be emitted.
         *
         * ```js
         * const body = 'hello world';
         * response.writeHead(200, {
         *   'Content-Length': Buffer.byteLength(body),
         *   'Content-Type': 'text/plain; charset=utf-8',
         * });
         * ```
         *
         * `Content-Length` is given in bytes not characters. The`Buffer.byteLength()` API may be used to determine the number of bytes in a
         * given encoding. On outbound messages, Node.js does not check if Content-Length
         * and the length of the body being transmitted are equal or not. However, when
         * receiving messages, Node.js will automatically reject messages when the`Content-Length` does not match the actual payload size.
         *
         * This method may be called at most one time on a message before `response.end()` is called.
         *
         * If `response.write()` or `response.end()` are called before calling
         * this, the implicit/mutable headers will be calculated and call this function.
         *
         * When headers have been set with `response.setHeader()`, they will be merged
         * with any headers passed to `response.writeHead()`, with the headers passed
         * to `response.writeHead()` given precedence.
         *
         * ```js
         * // Returns content-type = text/plain
         * const server = http2.createServer((req, res) => {
         *   res.setHeader('Content-Type', 'text/html; charset=utf-8');
         *   res.setHeader('X-Foo', 'bar');
         *   res.writeHead(200, { 'Content-Type': 'text/plain; charset=utf-8' });
         *   res.end('ok');
         * });
         * ```
         *
         * Attempting to set a header field name or value that contains invalid characters
         * will result in a `TypeError` being thrown.
         * @since v8.4.0
         */
        writeHead(statusCode: number, headers?: OutgoingHttpHeaders): this;
        writeHead(statusCode: number, statusMessage: string, headers?: OutgoingHttpHeaders): this;
        /**
         * Call `http2stream.pushStream()` with the given headers, and wrap the
         * given `Http2Stream` on a newly created `Http2ServerResponse` as the callback
         * parameter if successful. When `Http2ServerRequest` is closed, the callback is
         * called with an error `ERR_HTTP2_INVALID_STREAM`.
         * @since v8.4.0
         * @param headers An object describing the headers
         * @param callback Called once `http2stream.pushStream()` is finished, or either when the attempt to create the pushed `Http2Stream` has failed or has been rejected, or the state of
         * `Http2ServerRequest` is closed prior to calling the `http2stream.pushStream()` method
         */
        createPushResponse(headers: OutgoingHttpHeaders, callback: (err: Error | null, res: Http2ServerResponse) => void): void;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'drain', listener: () => void): this;
        addListener(event: 'error', listener: (error: Error) => void): this;
        addListener(event: 'finish', listener: () => void): this;
        addListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        addListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        addListener(event: string | symbol, listener: (...args: any[]) => void): this;
        emit(event: 'close'): boolean;
        emit(event: 'drain'): boolean;
        emit(event: 'error', error: Error): boolean;
        emit(event: 'finish'): boolean;
        emit(event: 'pipe', src: stream.Readable): boolean;
        emit(event: 'unpipe', src: stream.Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: 'close', listener: () => void): this;
        on(event: 'drain', listener: () => void): this;
        on(event: 'error', listener: (error: Error) => void): this;
        on(event: 'finish', listener: () => void): this;
        on(event: 'pipe', listener: (src: stream.Readable) => void): this;
        on(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        on(event: string | symbol, listener: (...args: any[]) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'drain', listener: () => void): this;
        once(event: 'error', listener: (error: Error) => void): this;
        once(event: 'finish', listener: () => void): this;
        once(event: 'pipe', listener: (src: stream.Readable) => void): this;
        once(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        once(event: string | symbol, listener: (...args: any[]) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'drain', listener: () => void): this;
        prependListener(event: 'error', listener: (error: Error) => void): this;
        prependListener(event: 'finish', listener: () => void): this;
        prependListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'drain', listener: () => void): this;
        prependOnceListener(event: 'error', listener: (error: Error) => void): this;
        prependOnceListener(event: 'finish', listener: () => void): this;
        prependOnceListener(event: 'pipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: 'unpipe', listener: (src: stream.Readable) => void): this;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): this;
    }
    export namespace constants {
        const NGHTTP2_SESSION_SERVER: number;
        const NGHTTP2_SESSION_CLIENT: number;
        const NGHTTP2_STREAM_STATE_IDLE: number;
        const NGHTTP2_STREAM_STATE_OPEN: number;
        const NGHTTP2_STREAM_STATE_RESERVED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_RESERVED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL: number;
        const NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE: number;
        const NGHTTP2_STREAM_STATE_CLOSED: number;
        const NGHTTP2_NO_ERROR: number;
        const NGHTTP2_PROTOCOL_ERROR: number;
        const NGHTTP2_INTERNAL_ERROR: number;
        const NGHTTP2_FLOW_CONTROL_ERROR: number;
        const NGHTTP2_SETTINGS_TIMEOUT: number;
        const NGHTTP2_STREAM_CLOSED: number;
        const NGHTTP2_FRAME_SIZE_ERROR: number;
        const NGHTTP2_REFUSED_STREAM: number;
        const NGHTTP2_CANCEL: number;
        const NGHTTP2_COMPRESSION_ERROR: number;
        const NGHTTP2_CONNECT_ERROR: number;
        const NGHTTP2_ENHANCE_YOUR_CALM: number;
        const NGHTTP2_INADEQUATE_SECURITY: number;
        const NGHTTP2_HTTP_1_1_REQUIRED: number;
        const NGHTTP2_ERR_FRAME_SIZE_ERROR: number;
        const NGHTTP2_FLAG_NONE: number;
        const NGHTTP2_FLAG_END_STREAM: number;
        const NGHTTP2_FLAG_END_HEADERS: number;
        const NGHTTP2_FLAG_ACK: number;
        const NGHTTP2_FLAG_PADDED: number;
        const NGHTTP2_FLAG_PRIORITY: number;
        const DEFAULT_SETTINGS_HEADER_TABLE_SIZE: number;
        const DEFAULT_SETTINGS_ENABLE_PUSH: number;
        const DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const DEFAULT_SETTINGS_MAX_FRAME_SIZE: number;
        const MAX_MAX_FRAME_SIZE: number;
        const MIN_MAX_FRAME_SIZE: number;
        const MAX_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_DEFAULT_WEIGHT: number;
        const NGHTTP2_SETTINGS_HEADER_TABLE_SIZE: number;
        const NGHTTP2_SETTINGS_ENABLE_PUSH: number;
        const NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS: number;
        const NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_FRAME_SIZE: number;
        const NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE: number;
        const PADDING_STRATEGY_NONE: number;
        const PADDING_STRATEGY_MAX: number;
        const PADDING_STRATEGY_CALLBACK: number;
        const HTTP2_HEADER_STATUS: string;
        const HTTP2_HEADER_METHOD: string;
        const HTTP2_HEADER_AUTHORITY: string;
        const HTTP2_HEADER_SCHEME: string;
        const HTTP2_HEADER_PATH: string;
        const HTTP2_HEADER_ACCEPT_CHARSET: string;
        const HTTP2_HEADER_ACCEPT_ENCODING: string;
        const HTTP2_HEADER_ACCEPT_LANGUAGE: string;
        const HTTP2_HEADER_ACCEPT_RANGES: string;
        const HTTP2_HEADER_ACCEPT: string;
        const HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN: string;
        const HTTP2_HEADER_AGE: string;
        const HTTP2_HEADER_ALLOW: string;
        const HTTP2_HEADER_AUTHORIZATION: string;
        const HTTP2_HEADER_CACHE_CONTROL: string;
        const HTTP2_HEADER_CONNECTION: string;
        const HTTP2_HEADER_CONTENT_DISPOSITION: string;
        const HTTP2_HEADER_CONTENT_ENCODING: string;
        const HTTP2_HEADER_CONTENT_LANGUAGE: string;
        const HTTP2_HEADER_CONTENT_LENGTH: string;
        const HTTP2_HEADER_CONTENT_LOCATION: string;
        const HTTP2_HEADER_CONTENT_MD5: string;
        const HTTP2_HEADER_CONTENT_RANGE: string;
        const HTTP2_HEADER_CONTENT_TYPE: string;
        const HTTP2_HEADER_COOKIE: string;
        const HTTP2_HEADER_DATE: string;
        const HTTP2_HEADER_ETAG: string;
        const HTTP2_HEADER_EXPECT: string;
        const HTTP2_HEADER_EXPIRES: string;
        const HTTP2_HEADER_FROM: string;
        const HTTP2_HEADER_HOST: string;
        const HTTP2_HEADER_IF_MATCH: string;
        const HTTP2_HEADER_IF_MODIFIED_SINCE: string;
        const HTTP2_HEADER_IF_NONE_MATCH: string;
        const HTTP2_HEADER_IF_RANGE: string;
        const HTTP2_HEADER_IF_UNMODIFIED_SINCE: string;
        const HTTP2_HEADER_LAST_MODIFIED: string;
        const HTTP2_HEADER_LINK: string;
        const HTTP2_HEADER_LOCATION: string;
        const HTTP2_HEADER_MAX_FORWARDS: string;
        const HTTP2_HEADER_PREFER: string;
        const HTTP2_HEADER_PROXY_AUTHENTICATE: string;
        const HTTP2_HEADER_PROXY_AUTHORIZATION: string;
        const HTTP2_HEADER_RANGE: string;
        const HTTP2_HEADER_REFERER: string;
        const HTTP2_HEADER_REFRESH: string;
        const HTTP2_HEADER_RETRY_AFTER: string;
        const HTTP2_HEADER_SERVER: string;
        const HTTP2_HEADER_SET_COOKIE: string;
        const HTTP2_HEADER_STRICT_TRANSPORT_SECURITY: string;
        const HTTP2_HEADER_TRANSFER_ENCODING: string;
        const HTTP2_HEADER_TE: string;
        const HTTP2_HEADER_UPGRADE: string;
        const HTTP2_HEADER_USER_AGENT: string;
        const HTTP2_HEADER_VARY: string;
        const HTTP2_HEADER_VIA: string;
        const HTTP2_HEADER_WWW_AUTHENTICATE: string;
        const HTTP2_HEADER_HTTP2_SETTINGS: string;
        const HTTP2_HEADER_KEEP_ALIVE: string;
        const HTTP2_HEADER_PROXY_CONNECTION: string;
        const HTTP2_METHOD_ACL: string;
        const HTTP2_METHOD_BASELINE_CONTROL: string;
        const HTTP2_METHOD_BIND: string;
        const HTTP2_METHOD_CHECKIN: string;
        const HTTP2_METHOD_CHECKOUT: string;
        const HTTP2_METHOD_CONNECT: string;
        const HTTP2_METHOD_COPY: string;
        const HTTP2_METHOD_DELETE: string;
        const HTTP2_METHOD_GET: string;
        const HTTP2_METHOD_HEAD: string;
        const HTTP2_METHOD_LABEL: string;
        const HTTP2_METHOD_LINK: string;
        const HTTP2_METHOD_LOCK: string;
        const HTTP2_METHOD_MERGE: string;
        const HTTP2_METHOD_MKACTIVITY: string;
        const HTTP2_METHOD_MKCALENDAR: string;
        const HTTP2_METHOD_MKCOL: string;
        const HTTP2_METHOD_MKREDIRECTREF: string;
        const HTTP2_METHOD_MKWORKSPACE: string;
        const HTTP2_METHOD_MOVE: string;
        const HTTP2_METHOD_OPTIONS: string;
        const HTTP2_METHOD_ORDERPATCH: string;
        const HTTP2_METHOD_PATCH: string;
        const HTTP2_METHOD_POST: string;
        const HTTP2_METHOD_PRI: string;
        const HTTP2_METHOD_PROPFIND: string;
        const HTTP2_METHOD_PROPPATCH: string;
        const HTTP2_METHOD_PUT: string;
        const HTTP2_METHOD_REBIND: string;
        const HTTP2_METHOD_REPORT: string;
        const HTTP2_METHOD_SEARCH: string;
        const HTTP2_METHOD_TRACE: string;
        const HTTP2_METHOD_UNBIND: string;
        const HTTP2_METHOD_UNCHECKOUT: string;
        const HTTP2_METHOD_UNLINK: string;
        const HTTP2_METHOD_UNLOCK: string;
        const HTTP2_METHOD_UPDATE: string;
        const HTTP2_METHOD_UPDATEREDIRECTREF: string;
        const HTTP2_METHOD_VERSION_CONTROL: string;
        const HTTP_STATUS_CONTINUE: number;
        const HTTP_STATUS_SWITCHING_PROTOCOLS: number;
        const HTTP_STATUS_PROCESSING: number;
        const HTTP_STATUS_OK: number;
        const HTTP_STATUS_CREATED: number;
        const HTTP_STATUS_ACCEPTED: number;
        const HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION: number;
        const HTTP_STATUS_NO_CONTENT: number;
        const HTTP_STATUS_RESET_CONTENT: number;
        const HTTP_STATUS_PARTIAL_CONTENT: number;
        const HTTP_STATUS_MULTI_STATUS: number;
        const HTTP_STATUS_ALREADY_REPORTED: number;
        const HTTP_STATUS_IM_USED: number;
        const HTTP_STATUS_MULTIPLE_CHOICES: number;
        const HTTP_STATUS_MOVED_PERMANENTLY: number;
        const HTTP_STATUS_FOUND: number;
        const HTTP_STATUS_SEE_OTHER: number;
        const HTTP_STATUS_NOT_MODIFIED: number;
        const HTTP_STATUS_USE_PROXY: number;
        const HTTP_STATUS_TEMPORARY_REDIRECT: number;
        const HTTP_STATUS_PERMANENT_REDIRECT: number;
        const HTTP_STATUS_BAD_REQUEST: number;
        const HTTP_STATUS_UNAUTHORIZED: number;
        const HTTP_STATUS_PAYMENT_REQUIRED: number;
        const HTTP_STATUS_FORBIDDEN: number;
        const HTTP_STATUS_NOT_FOUND: number;
        const HTTP_STATUS_METHOD_NOT_ALLOWED: number;
        const HTTP_STATUS_NOT_ACCEPTABLE: number;
        const HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED: number;
        const HTTP_STATUS_REQUEST_TIMEOUT: number;
        const HTTP_STATUS_CONFLICT: number;
        const HTTP_STATUS_GONE: number;
        const HTTP_STATUS_LENGTH_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_FAILED: number;
        const HTTP_STATUS_PAYLOAD_TOO_LARGE: number;
        const HTTP_STATUS_URI_TOO_LONG: number;
        const HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE: number;
        const HTTP_STATUS_RANGE_NOT_SATISFIABLE: number;
        const HTTP_STATUS_EXPECTATION_FAILED: number;
        const HTTP_STATUS_TEAPOT: number;
        const HTTP_STATUS_MISDIRECTED_REQUEST: number;
        const HTTP_STATUS_UNPROCESSABLE_ENTITY: number;
        const HTTP_STATUS_LOCKED: number;
        const HTTP_STATUS_FAILED_DEPENDENCY: number;
        const HTTP_STATUS_UNORDERED_COLLECTION: number;
        const HTTP_STATUS_UPGRADE_REQUIRED: number;
        const HTTP_STATUS_PRECONDITION_REQUIRED: number;
        const HTTP_STATUS_TOO_MANY_REQUESTS: number;
        const HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE: number;
        const HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS: number;
        const HTTP_STATUS_INTERNAL_SERVER_ERROR: number;
        const HTTP_STATUS_NOT_IMPLEMENTED: number;
        const HTTP_STATUS_BAD_GATEWAY: number;
        const HTTP_STATUS_SERVICE_UNAVAILABLE: number;
        const HTTP_STATUS_GATEWAY_TIMEOUT: number;
        const HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED: number;
        const HTTP_STATUS_VARIANT_ALSO_NEGOTIATES: number;
        const HTTP_STATUS_INSUFFICIENT_STORAGE: number;
        const HTTP_STATUS_LOOP_DETECTED: number;
        const HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED: number;
        const HTTP_STATUS_NOT_EXTENDED: number;
        const HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED: number;
    }
    /**
     * This symbol can be set as a property on the HTTP/2 headers object with
     * an array value in order to provide a list of headers considered sensitive.
     */
    export const sensitiveHeaders: symbol;
    /**
     * Returns an object containing the default settings for an `Http2Session`instance. This method returns a new object instance every time it is called
     * so instances returned may be safely modified for use.
     * @since v8.4.0
     */
    export function getDefaultSettings(): Settings;
    /**
     * Returns a `Buffer` instance containing serialized representation of the given
     * HTTP/2 settings as specified in the [HTTP/2](https://tools.ietf.org/html/rfc7540) specification. This is intended
     * for use with the `HTTP2-Settings` header field.
     *
     * ```js
     * const http2 = require('http2');
     *
     * const packed = http2.getPackedSettings({ enablePush: false });
     *
     * console.log(packed.toString('base64'));
     * // Prints: AAIAAAAA
     * ```
     * @since v8.4.0
     */
    export function getPackedSettings(settings: Settings): Buffer;
    /**
     * Returns a `HTTP/2 Settings Object` containing the deserialized settings from
     * the given `Buffer` as generated by `http2.getPackedSettings()`.
     * @since v8.4.0
     * @param buf The packed settings.
     */
    export function getUnpackedSettings(buf: Uint8Array): Settings;
    /**
     * Returns a `net.Server` instance that creates and manages `Http2Session`instances.
     *
     * Since there are no browsers known that support [unencrypted HTTP/2](https://http2.github.io/faq/#does-http2-require-encryption), the use of {@link createSecureServer} is necessary when
     * communicating
     * with browser clients.
     *
     * ```js
     * const http2 = require('http2');
     *
     * // Create an unencrypted HTTP/2 server.
     * // Since there are no browsers known that support
     * // unencrypted HTTP/2, the use of `http2.createSecureServer()`
     * // is necessary when communicating with browser clients.
     * const server = http2.createServer();
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(80);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;
    export function createServer(options: ServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2Server;
    /**
     * Returns a `tls.Server` instance that creates and manages `Http2Session`instances.
     *
     * ```js
     * const http2 = require('http2');
     * const fs = require('fs');
     *
     * const options = {
     *   key: fs.readFileSync('server-key.pem'),
     *   cert: fs.readFileSync('server-cert.pem')
     * };
     *
     * // Create a secure HTTP/2 server
     * const server = http2.createSecureServer(options);
     *
     * server.on('stream', (stream, headers) => {
     *   stream.respond({
     *     'content-type': 'text/html; charset=utf-8',
     *     ':status': 200
     *   });
     *   stream.end('<h1>Hello World</h1>');
     * });
     *
     * server.listen(80);
     * ```
     * @since v8.4.0
     * @param onRequestHandler See `Compatibility API`
     */
    export function createSecureServer(onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;
    export function createSecureServer(options: SecureServerOptions, onRequestHandler?: (request: Http2ServerRequest, response: Http2ServerResponse) => void): Http2SecureServer;
    /**
     * Returns a `ClientHttp2Session` instance.
     *
     * ```js
     * const http2 = require('http2');
     * const client = http2.connect('https://localhost:1234');
     *
     * // Use the client
     *
     * client.close();
     * ```
     * @since v8.4.0
     * @param authority The remote HTTP/2 server to connect to. This must be in the form of a minimal, valid URL with the `http://` or `https://` prefix, host name, and IP port (if a non-default port
     * is used). Userinfo (user ID and password), path, querystring, and fragment details in the URL will be ignored.
     * @param listener Will be registered as a one-time listener of the {@link 'connect'} event.
     */
    export function connect(authority: string | url.URL, listener: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void): ClientHttp2Session;
    export function connect(
        authority: string | url.URL,
        options?: ClientSessionOptions | SecureClientSessionOptions,
        listener?: (session: ClientHttp2Session, socket: net.Socket | tls.TLSSocket) => void
    ): ClientHttp2Session;
}
declare module 'node:http2' {
    export * from 'http2';
}
