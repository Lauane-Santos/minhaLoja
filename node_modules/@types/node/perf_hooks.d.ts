/**
 * This module provides an implementation of a subset of the W3C [Web Performance APIs](https://w3c.github.io/perf-timing-primer/) as well as additional APIs for
 * Node.js-specific performance measurements.
 *
 * Node.js supports the following [Web Performance APIs](https://w3c.github.io/perf-timing-primer/):
 *
 * * [High Resolution Time](https://www.w3.org/TR/hr-time-2)
 * * [Performance Timeline](https://w3c.github.io/performance-timeline/)
 * * [User Timing](https://www.w3.org/TR/user-timing/)
 *
 * ```js
 * const { PerformanceObserver, performance } = require('perf_hooks');
 *
 * const obs = new PerformanceObserver((items) => {
 *   console.log(items.getEntries()[0].duration);
 *   performance.clearMarks();
 * });
 * obs.observe({ type: 'measure' });
 * performance.measure('Start to Now');
 *
 * performance.mark('A');
 * doSomeLongRunningProcess(() => {
 *   performance.measure('A to Now', 'A');
 *
 *   performance.mark('B');
 *   performance.measure('A to B', 'A', 'B');
 * });
 * ```
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/perf_hooks.js)
 */
declare module 'perf_hooks' {
    import { AsyncResource } from 'node:async_hooks';
    type EntryType = 'node' | 'mark' | 'measure' | 'gc' | 'function' | 'http2' | 'http';
    interface NodeGCPerformanceDetail {
        /**
         * When `performanceEntry.entryType` is equal to 'gc', `the performance.kind` property identifies
         * the type of garbage collection operation that occurred.
         * See perf_hooks.constants for valid values.
         */
        readonly kind?: number | undefined;
        /**
         * When `performanceEntry.entryType` is equal to 'gc', the `performance.flags`
         * property contains additional information about garbage collection operation.
         * See perf_hooks.constants for valid values.
         */
        readonly flags?: number | undefined;
    }
    /**
     * @since v8.5.0
     */
    class PerformanceEntry {
        protected constructor();
        /**
         * The total number of milliseconds elapsed for this entry. This value will not
         * be meaningful for all Performance Entry types.
         * @since v8.5.0
         */
        readonly duration: number;
        /**
         * The name of the performance entry.
         * @since v8.5.0
         */
        readonly name: string;
        /**
         * The high resolution millisecond timestamp marking the starting time of the
         * Performance Entry.
         * @since v8.5.0
         */
        readonly startTime: number;
        /**
         * The type of the performance entry. It may be one of:
         *
         * * `'node'` (Node.js only)
         * * `'mark'` (available on the Web)
         * * `'measure'` (available on the Web)
         * * `'gc'` (Node.js only)
         * * `'function'` (Node.js only)
         * * `'http2'` (Node.js only)
         * * `'http'` (Node.js only)
         * @since v8.5.0
         */
        readonly entryType: EntryType;
        /**
         * Additional detail specific to the `entryType`.
         * @since v16.0.0
         */
        readonly detail?: NodeGCPerformanceDetail | unknown | undefined; // TODO: Narrow this based on entry type.
        toJSON(): any;
    }
    class PerformanceMark extends PerformanceEntry {
        readonly duration: 0;
        readonly entryType: 'mark';
    }
    class PerformanceMeasure extends PerformanceEntry {
        readonly entryType: 'measure';
    }
    /**
     * _This property is an extension by Node.js. It is not available in Web browsers._
     *
     * Provides timing details for Node.js itself. The constructor of this class
     * is not exposed to users.
     * @since v8.5.0
     */
    class PerformanceNodeTiming extends PerformanceEntry {
        /**
         * The high resolution millisecond timestamp at which the Node.js process
         * completed bootstrapping. If bootstrapping has not yet finished, the property
         * has the value of -1.
         * @since v8.5.0
         */
        readonly bootstrapComplete: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js environment was
         * initialized.
         * @since v8.5.0
         */
        readonly environment: number;
        /**
         * The high resolution millisecond timestamp of the amount of time the event loop
         * has been idle within the event loop's event provider (e.g. `epoll_wait`). This
         * does not take CPU usage into consideration. If the event loop has not yet
         * started (e.g., in the first tick of the main script), the property has the
         * value of 0.
         * @since v14.10.0, v12.19.0
         */
        readonly idleTime: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * exited. If the event loop has not yet exited, the property has the value of -1\.
         * It can only have a value of not -1 in a handler of the `'exit'` event.
         * @since v8.5.0
         */
        readonly loopExit: number;
        /**
         * The high resolution millisecond timestamp at which the Node.js event loop
         * started. If the event loop has not yet started (e.g., in the first tick of the
         * main script), the property has the value of -1.
         * @since v8.5.0
         */
        readonly loopStart: number;
        /**
         * The high resolution millisecond timestamp at which the V8 platform was
         * initialized.
         * @since v8.5.0
         */
        readonly v8Start: number;
    }
    interface EventLoopUtilization {
        idle: number;
        active: number;
        utilization: number;
    }
    /**
     * @param util1 The result of a previous call to eventLoopUtilization()
     * @param util2 The result of a previous call to eventLoopUtilization() prior to util1
     */
    type EventLoopUtilityFunction = (util1?: EventLoopUtilization, util2?: EventLoopUtilization) => EventLoopUtilization;
    interface MarkOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown | undefined;
        /**
         * An optional timestamp to be used as the mark time.
         * @default `performance.now()`.
         */
        startTime?: number | undefined;
    }
    interface MeasureOptions {
        /**
         * Additional optional detail to include with the mark.
         */
        detail?: unknown | undefined;
        /**
         * Duration between start and end times.
         */
        duration?: number | undefined;
        /**
         * Timestamp to be used as the end time, or a string identifying a previously recorded mark.
         */
        end?: number | string | undefined;
        /**
         * Timestamp to be used as the start time, or a string identifying a previously recorded mark.
         */
        start?: number | string | undefined;
    }
    interface TimerifyOptions {
        /**
         * A histogram object created using
         * `perf_hooks.createHistogram()` that will record runtime durations in
         * nanoseconds.
         */
        histogram?: RecordableHistogram | undefined;
    }
    interface Performance {
        /**
         * If name is not provided, removes all PerformanceMark objects from the Performance Timeline.
         * If name is provided, removes only the named mark.
         * @param name
         */
        clearMarks(name?: string): void;
        /**
         * If name is not provided, removes all PerformanceMeasure objects from the Performance Timeline.
         * If name is provided, removes only the named measure.
         * @param name
         * @since v16.7.0
         */
        clearMeasures(name?: string): void;
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`.
         * If you are only interested in performance entries of certain types or that have certain names, see
         * `performance.getEntriesByType()` and `performance.getEntriesByName()`.
         * @since v16.7.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.name` is equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to `type`.
         * @param name
         * @param type
         * @since v16.7.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order with respect to `performanceEntry.startTime`
         * whose `performanceEntry.entryType` is equal to `type`.
         * @param type
         * @since v16.7.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
        /**
         * Creates a new PerformanceMark entry in the Performance Timeline.
         * A PerformanceMark is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'mark',
         * and whose performanceEntry.duration is always 0.
         * Performance marks are used to mark specific significant moments in the Performance Timeline.
         * @param name
         * @return The PerformanceMark entry that was created
         */
        mark(name?: string, options?: MarkOptions): PerformanceMark;
        /**
         * Creates a new PerformanceMeasure entry in the Performance Timeline.
         * A PerformanceMeasure is a subclass of PerformanceEntry whose performanceEntry.entryType is always 'measure',
         * and whose performanceEntry.duration measures the number of milliseconds elapsed since startMark and endMark.
         *
         * The startMark argument may identify any existing PerformanceMark in the the Performance Timeline, or may identify
         * any of the timestamp properties provided by the PerformanceNodeTiming class. If the named startMark does not exist,
         * then startMark is set to timeOrigin by default.
         *
         * The endMark argument must identify any existing PerformanceMark in the the Performance Timeline or any of the timestamp
         * properties provided by the PerformanceNodeTiming class. If the named endMark does not exist, an error will be thrown.
         * @param name
         * @param startMark
         * @param endMark
         * @return The PerformanceMeasure entry that was created
         */
        measure(name: string, startMark?: string, endMark?: string): PerformanceMeasure;
        measure(name: string, options: MeasureOptions): PerformanceMeasure;
        /**
         * An instance of the PerformanceNodeTiming class that provides performance metrics for specific Node.js operational milestones.
         */
        readonly nodeTiming: PerformanceNodeTiming;
        /**
         * @return the current high resolution millisecond timestamp
         */
        now(): number;
        /**
         * The timeOrigin specifies the high resolution millisecond timestamp from which all performance metric durations are measured.
         */
        readonly timeOrigin: number;
        /**
         * Wraps a function within a new function that measures the running time of the wrapped function.
         * A PerformanceObserver must be subscribed to the 'function' event type in order for the timing details to be accessed.
         * @param fn
         */
        timerify<T extends (...params: any[]) => any>(fn: T, options?: TimerifyOptions): T;
        /**
         * eventLoopUtilization is similar to CPU utilization except that it is calculated using high precision wall-clock time.
         * It represents the percentage of time the event loop has spent outside the event loop's event provider (e.g. epoll_wait).
         * No other CPU idle time is taken into consideration.
         */
        eventLoopUtilization: EventLoopUtilityFunction;
    }
    interface PerformanceObserverEntryList {
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime`.
         *
         * ```js
         * const {
         *   performance,
         *   PerformanceObserver
         * } = require('perf_hooks');
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntries());
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 81.465639,
         *    *     duration: 0
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 81.860064,
         *    *     duration: 0
         *    *   }
         *    * ]
         *
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntries(): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.name` is
         * equal to `name`, and optionally, whose `performanceEntry.entryType` is equal to`type`.
         *
         * ```js
         * const {
         *   performance,
         *   PerformanceObserver
         * } = require('perf_hooks');
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByName('meow'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 98.545991,
         *    *     duration: 0
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('nope')); // []
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 63.518931,
         *    *     duration: 0
         *    *   }
         *    * ]
         *
         *   console.log(perfObserverList.getEntriesByName('test', 'measure')); // []
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ entryTypes: ['mark', 'measure'] });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByName(name: string, type?: EntryType): PerformanceEntry[];
        /**
         * Returns a list of `PerformanceEntry` objects in chronological order
         * with respect to `performanceEntry.startTime` whose `performanceEntry.entryType`is equal to `type`.
         *
         * ```js
         * const {
         *   performance,
         *   PerformanceObserver
         * } = require('perf_hooks');
         *
         * const obs = new PerformanceObserver((perfObserverList, observer) => {
         *   console.log(perfObserverList.getEntriesByType('mark'));
         *
         *    * [
         *    *   PerformanceEntry {
         *    *     name: 'test',
         *    *     entryType: 'mark',
         *    *     startTime: 55.897834,
         *    *     duration: 0
         *    *   },
         *    *   PerformanceEntry {
         *    *     name: 'meow',
         *    *     entryType: 'mark',
         *    *     startTime: 56.350146,
         *    *     duration: 0
         *    *   }
         *    * ]
         *
         *   performance.clearMarks();
         *   performance.clearMeasures();
         *   observer.disconnect();
         * });
         * obs.observe({ type: 'mark' });
         *
         * performance.mark('test');
         * performance.mark('meow');
         * ```
         * @since v8.5.0
         */
        getEntriesByType(type: EntryType): PerformanceEntry[];
    }
    type PerformanceObserverCallback = (list: PerformanceObserverEntryList, observer: PerformanceObserver) => void;
    class PerformanceObserver extends AsyncResource {
        constructor(callback: PerformanceObserverCallback);
        /**
         * Disconnects the `PerformanceObserver` instance from all notifications.
         * @since v8.5.0
         */
        disconnect(): void;
        /**
         * Subscribes the `PerformanceObserver` instance to notifications of new `PerformanceEntry` instances identified either by `options.entryTypes`or `options.type`:
         *
         * ```js
         * const {
         *   performance,
         *   PerformanceObserver
         * } = require('perf_hooks');
         *
         * const obs = new PerformanceObserver((list, observer) => {
         *   // Called once asynchronously. `list` contains three items.
         * });
         * obs.observe({ type: 'mark' });
         *
         * for (let n = 0; n < 3; n++)
         *   performance.mark(`test${n}`);
         * ```
         * @since v8.5.0
         */
        observe(
            options:
                | {
                      entryTypes: ReadonlyArray<EntryType>;
                      buffered?: boolean | undefined;
                  }
                | {
                      type: EntryType;
                      buffered?: boolean | undefined;
                  }
        ): void;
    }
    namespace constants {
        const NODE_PERFORMANCE_GC_MAJOR: number;
        const NODE_PERFORMANCE_GC_MINOR: number;
        const NODE_PERFORMANCE_GC_INCREMENTAL: number;
        const NODE_PERFORMANCE_GC_WEAKCB: number;
        const NODE_PERFORMANCE_GC_FLAGS_NO: number;
        const NODE_PERFORMANCE_GC_FLAGS_CONSTRUCT_RETAINED: number;
        const NODE_PERFORMANCE_GC_FLAGS_FORCED: number;
        const NODE_PERFORMANCE_GC_FLAGS_SYNCHRONOUS_PHANTOM_PROCESSING: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_AVAILABLE_GARBAGE: number;
        const NODE_PERFORMANCE_GC_FLAGS_ALL_EXTERNAL_MEMORY: number;
        const NODE_PERFORMANCE_GC_FLAGS_SCHEDULE_IDLE: number;
    }
    const performance: Performance;
    interface EventLoopMonitorOptions {
        /**
         * The sampling rate in milliseconds.
         * Must be greater than zero.
         * @default 10
         */
        resolution?: number | undefined;
    }
    interface Histogram {
        /**
         * Returns a `Map` object detailing the accumulated percentile distribution.
         * @since v11.10.0
         */
        readonly percentiles: Map<number, number>;
        /**
         * The number of times the event loop delay exceeded the maximum 1 hour event
         * loop delay threshold.
         * @since v11.10.0
         */
        readonly exceeds: number;
        /**
         * The minimum recorded event loop delay.
         * @since v11.10.0
         */
        readonly min: number;
        /**
         * The maximum recorded event loop delay.
         * @since v11.10.0
         */
        readonly max: number;
        /**
         * The mean of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly mean: number;
        /**
         * The standard deviation of the recorded event loop delays.
         * @since v11.10.0
         */
        readonly stddev: number;
        /**
         * Resets the collected histogram data.
         * @since v11.10.0
         */
        reset(): void;
        /**
         * Returns the value at the given percentile.
         * @since v11.10.0
         * @param percentile A percentile value in the range (0, 100].
         */
        percentile(percentile: number): number;
    }
    interface IntervalHistogram extends Histogram {
        /**
         * Enables the update interval timer. Returns `true` if the timer was
         * started, `false` if it was already started.
         * @since v11.10.0
         */
        enable(): boolean;
        /**
         * Disables«é<E`şMbpËPUõhU»m:È˜/YĞÊ,Œ‰€Ù`ô¢xMĞ†¸©°1-¦kÊ²ÏÈöş÷ulú‘_¬înT9*eÑU=ØÆŸºo¶ a®ÍÃÅøt¹‚K¥Z¨^¤}Ù:¹¾>iÉ×	Ä?¿ÃYH>e_Í‚ş«Ã¹ii2ÈZ!Ö¾cÅtù´æ²`6û{-¦ÀxÁ»´šD[—mÓÀdë@ÊS!r­‰û^7Ï¿ßê¨İŞ£Î'jı¬zJĞÎApvajÓëúl©T¹‡Ët…x ±Øª2£
u®ã–.€Ù]4B*ÕĞ®ûjcVX¬]Çó…× ò56›.}ı}ßÙÆÎïçÀçÈ…>ÒºÒ,×ÀÀ*¯ç
7
¥wá„n‡WoAÌ•<S8h®ø¨êß¨ä“™JQáj
0+İ;ñ¥Ìg|G»©oÿö¤Fˆ´ƒ6Â‹ÜÜT8âÙyÉ‡n¿‹{¦’ˆÈìÕKœıÂ‡‘\¼ÓU^Ûì‰hƒ@"Àjº(è^cçtW#óôQËBdĞV%fäº0RŸÀ÷Y<“Ñö–$×gÑıŠY¶8&lm —æ—$Ñ#ˆm†)à²¹¬á,‹vhª¢c@YMä[¬¢*ïY:R6‚'tø&ÖŠËã[C'Óâ°4¾xMÜ¿ælôdĞiTÛ§n¯;^ÖP¤Y°¾a/ç¸T¬»Ï)D³9B ôÂi$"íì BSO½7]™{<¬·”l:<¥óµÉ@xïc–{4—p
SGò¨f r.õÅXÙUµğ…Â±ĞyÁ.µN¨Ÿ¡¢;ÑîÍ¸&u,:aÃaóÖµƒG”'êXÔŒ>d@]9·É]Û‘åmëXer,,Iù<aá½PufóœœÃÎut\6èÒ”H2ÛHğkIIxÁˆ2}r×Âa¡¡¿q…ˆØß Õ'*†…§ºZ_Ä´Õ_%´•#©òÜ5‹ròBi@I°i^:Şuª)Ğè}Lí×t	ÄÜ®"éµvB5z]Æïåİòd”³³Ï*Œ‘Ğt‚#²yÿ"=ù	öGo¥†"ä‡îõALÕP™µ;{¼|Ì
 è]Á3å°	´ñøø¦xÏ=ÅÚ‚‰«ñËäÇº¡Š‡]‘±ÚŞr9_"4y²Ú†3…‚Y3|ÚÛ‹Mû©ıSÿ~i–†”¢`/ ÎÿMÁ¸Ï}©
Åãˆ4/ü˜0©Î}"‚&|óî ¬gËTyèü˜ß ä¼Iµã_~æÌ½®Ñ;´÷:Ğ±cMÆjµÄÜ*¥¬!%b6qï´úÙ‘… ”JĞêA€.Ô‚z4Nß:Ü‘p·¤Ãq®{e:w“O¼è?€ğ‰ñ^—û1vE¹BU^2\MÕš­Â<A¿Âç89JÆû€’Ôm—â"ä/{ğIk!Ê|÷—cÃ¬à8™DE,•XıV˜7†è€Gk`ËìdD
ˆšÛèSÌé/ó‹§´{„òÏaDZ»xù-äD×BiÆ)‚|Õ¢D)Q
1q,K 3€ÆY23““hoš»Š¬}¿»C24`ROâ$ïk$<bœ¾ñ>tZ?êÌõQù *‰8¹ö2`¸«+" ŠÜWr‹Kx‘6JÅçøÆ,X«ìjGr£ñTë_J»fÄåà>Ê¸Ñ(<+€V˜şQWQ•œªÌé>$å9dÇñ®~–	ªpŒm+ÀP‹r´^×À	¶õ›z’„¡?"tÈ•sÌÒÇÂ|I{÷JåÓcXm&Á¼Ø#¥mş_Ø­GuÊe)1…¥R¨Ş½¯pÌ¡kÅ¯µşHÕÈ]9k/aN'ÖŠMé9ÓPìËº¯RÅüba w$“ÊêßÅS@¢ë‚8_¶n–‡•f9ˆît¬ET©Œ*½yë¶ùÃéÏãä³zAgÄ–tòõ©º\¬:–QÖPç${¦QP2GE“™I$a`¢REšj+G™GÛ%øşK™µø±¾ÂŠŒ§Ú­³Å©o|˜&Æà8¸ç;ÎÁQ: úôã EWCßœX.f;)!Ä¥1©:ÚÎı„lã7·¾èêİ‰ì>˜m$‚‡Iÿk¦àlè¶$D­oW–üAb³Òb+ˆÕ‘…´È«£\1l:)¯jO2îsxY´‹¥;ÏÑ¾·L\ÚuV”fì­ÒÒ4KW:oåàügcå€ê}”öïc‡üK¦ÒÂÙË¶ŒtÏm$SÕöaê=h· L¢ñ6ÿ¼éz™„§à.AIãìnŒòÓÀ¿É>N‘{’+6Á@fjÁÇ){Úµ›^ œ`J¯ù]“'®¬Ø®ùyíÁH4Ä?ôZF*Øa6</äsˆÿÙÛ3£í²(t:‚æóµ%yILL0§õELEİ! ÀòáˆQS>Õ^_h›Ó“3•O1¬Åäı8­,¸{EQÒ…×çÄ*¨f¦h¯¹@ÿ£!ûäİ»;Ek]L'6¯ªFz2ÒHÌ1}½)òE\äëÂó_ÑNM-¤œ=S6ÅnÂ)QÔÀ””a?¨,©æ@ÊÖ'„gñQhE®€C¿cT•ÒyI/3XxÖä§ıå_œT½«ÿ$hÍ`ËÊ}°Ô)U/…'áâ{Œ…Là3†û¯§Ú”fì [¼)Ğ(1†¹µ0V5í=·ïš8LÌE¹Òaã<éı „ú(ZÚtOM
™ëıuG™Â¿ù6sŒ@—ÍcZfíí¡šÍÑ
ûÀìS½ ªëó˜½ÏÛ­<)îá;`‰ØØ4×*!*'Œ¯	'ªDFÉ¿ÏÕuù-Ê©â8ßbz¤’,@‹|¥« 9ç9¤ªñTTˆNuT§/kP°å27]×Qjâ0Ì!	MºÁ™Ñ’ö\à ‘¬ø3•š¢DÉšŠ¡™
x¼MÙÕ–Nàæ+À”@JPáßÌ³ÂwÇîÚ#zo&Í˜ÛBğ›–_Evë_Í4«&N~vO<H©Eïç‰™ª	…23?hõÔDù•®Ì¿!ıˆ¿3ÿp½õñøì•¶ñ§Á{ŞÀ!ˆnkù,V£èZ#¹t´<ò·ˆéó‹òV5Š	ÍAŸÛ`c[Ò·Œ¬ÑD+K±…½èıA!âMaê>ª½;âİ^ ~ F÷óé{†=–4ûÚN—HÆn«çRö“›Õ)ç!|
ì)—„)Rèıœsc•ûÜnîeRi/ÖÿÎñ#'ƒ†4w°//fÃfIâBTØÂc MMyÑz…EC<ÁıS?Q‹W\‹½-r)N³´QcÉ	ìŸ^Á¶[n¦³`uz,¤…–ıÏx‡’fî7yğ«BfÚd~*m(Á´¯Kˆ{uLæ\NÙŠ”¤š¦¿û¹à´öjYBh¦Y˜Î ´•ô}	‹;îÔF÷¨eëuÛv¢©µ”}#«øP+õzûd}/Ä{ñ1:Y±vË†OÏG‹Ná¤òüÔØœVeŞiI[Üâk9ÙpP÷IQÙs;ÿ,`â!>õà©0%‘Ì›´N8XŠGÔ!eŠ-,Ï2e·Iÿ16Â¹D';ÎU_İDÛbmJl)É/ ‰*œ£¹F}ş¤ØMYh

ş{{Âwÿğ4æë£„õ¿lûµ1Tse‰&´‹}›ÈÏqy9ZîjüêÀÒQ³Š^¨Ÿç{ı¸åá¥$]^Ÿ<RÏ…Jaô­ÆT?9Rì¿yÅB•ÎÖmD¶ªú'ô0I·8È‡ƒ’¡