/**
 * HTTPS is the HTTP protocol over TLS/SSL. In Node.js this is implemented as a
 * separate module.
 * @see [source](https://github.com/nodejs/node/blob/v18.0.0/lib/https.js)
 */
declare module 'https' {
    import { Duplex } from 'node:stream';
    import * as tls from 'node:tls';
    import * as http from 'node:http';
    import { URL } from 'node:url';
    type ServerOptions<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > = tls.SecureContextOptions & tls.TlsOptions & http.ServerOptions<Request, Response>;
    type RequestOptions = http.RequestOptions &
        tls.SecureContextOptions & {
            rejectUnauthorized?: boolean | undefined; // Defaults to true
            servername?: string | undefined; // SNI TLS Extension
        };
    interface AgentOptions extends http.AgentOptions, tls.ConnectionOptions {
        rejectUnauthorized?: boolean | undefined;
        maxCachedSessions?: number | undefined;
    }
    /**
     * An `Agent` object for HTTPS similar to `http.Agent`. See {@link request} for more information.
     * @since v0.4.5
     */
    class Agent extends http.Agent {
        constructor(options?: AgentOptions);
        options: AgentOptions;
    }
    interface Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends http.Server<Request, Response> {}
    /**
     * See `http.Server` for more information.
     * @since v0.3.4
     */
    class Server<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    > extends tls.Server {
        constructor(requestListener?: http.RequestListener<Request, Response>);
        constructor(
            options: ServerOptions<Request, Response>,
            requestListener?: http.RequestListener<Request, Response>,
        );
        /**
         * Closes all connections connected to this server.
         * @since v18.2.0
         */
        closeAllConnections(): void;
        /**
         * Closes all connections connected to this server which are not sending a request or waiting for a response.
         * @since v18.2.0
         */
        closeIdleConnections(): void;
        addListener(event: string, listener: (...args: any[]) => void): this;
        addListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        addListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        addListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        addListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        addListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        addListener(event: 'close', listener: () => void): this;
        addListener(event: 'connection', listener: (socket: Duplex) => void): this;
        addListener(event: 'error', listener: (err: Error) => void): this;
        addListener(event: 'listening', listener: () => void): this;
        addListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        addListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        addListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        addListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        addListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        addListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        emit(event: string, ...args: any[]): boolean;
        emit(event: 'keylog', line: Buffer, tlsSocket: tls.TLSSocket): boolean;
        emit(
            event: 'newSession',
            sessionId: Buffer,
            sessionData: Buffer,
            callback: (err: Error, resp: Buffer) => void,
        ): boolean;
        emit(
            event: 'OCSPRequest',
            certificate: Buffer,
            issuer: Buffer,
            callback: (err: Error | null, resp: Buffer) => void,
        ): boolean;
        emit(event: 'resumeSession', sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void): boolean;
        emit(event: 'secureConnection', tlsSocket: tls.TLSSocket): boolean;
        emit(event: 'tlsClientError', err: Error, tlsSocket: tls.TLSSocket): boolean;
        emit(event: 'close'): boolean;
        emit(event: 'connection', socket: Duplex): boolean;
        emit(event: 'error', err: Error): boolean;
        emit(event: 'listening'): boolean;
        emit(
            event: 'checkContinue',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(
            event: 'checkExpectation',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'clientError', err: Error, socket: Duplex): boolean;
        emit(event: 'connect', req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        emit(
            event: 'request',
            req: InstanceType<Request>,
            res: InstanceType<Response> & { req: InstanceType<Request> },
        ): boolean;
        emit(event: 'upgrade', req: InstanceType<Request>, socket: Duplex, head: Buffer): boolean;
        on(event: string, listener: (...args: any[]) => void): this;
        on(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        on(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        on(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        on(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        on(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        on(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        on(event: 'close', listener: () => void): this;
        on(event: 'connection', listener: (socket: Duplex) => void): this;
        on(event: 'error', listener: (err: Error) => void): this;
        on(event: 'listening', listener: () => void): this;
        on(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        on(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        on(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        on(event: 'connect', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        on(event: 'request', listener: http.RequestListener<Request, Response>): this;
        on(event: 'upgrade', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: string, listener: (...args: any[]) => void): this;
        once(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        once(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        once(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        once(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        once(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        once(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        once(event: 'close', listener: () => void): this;
        once(event: 'connection', listener: (socket: Duplex) => void): this;
        once(event: 'error', listener: (err: Error) => void): this;
        once(event: 'listening', listener: () => void): this;
        once(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        once(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        once(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        once(event: 'connect', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        once(event: 'request', listener: http.RequestListener<Request, Response>): this;
        once(event: 'upgrade', listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void): this;
        prependListener(event: string, listener: (...args: any[]) => void): this;
        prependListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependListener(event: 'close', listener: () => void): this;
        prependListener(event: 'connection', listener: (socket: Duplex) => void): this;
        prependListener(event: 'error', listener: (err: Error) => void): this;
        prependListener(event: 'listening', listener: () => void): this;
        prependListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        prependListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        prependListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        prependListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        prependListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: string, listener: (...args: any[]) => void): this;
        prependOnceListener(event: 'keylog', listener: (line: Buffer, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(
            event: 'newSession',
            listener: (sessionId: Buffer, sessionData: Buffer, callback: (err: Error, resp: Buffer) => void) => void,
        ): this;
        prependOnceListener(
            event: 'OCSPRequest',
            listener: (
                certificate: Buffer,
                issuer: Buffer,
                callback: (err: Error | null, resp: Buffer) => void,
            ) => void,
        ): this;
        prependOnceListener(
            event: 'resumeSession',
            listener: (sessionId: Buffer, callback: (err: Error, sessionData: Buffer) => void) => void,
        ): this;
        prependOnceListener(event: 'secureConnection', listener: (tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: 'tlsClientError', listener: (err: Error, tlsSocket: tls.TLSSocket) => void): this;
        prependOnceListener(event: 'close', listener: () => void): this;
        prependOnceListener(event: 'connection', listener: (socket: Duplex) => void): this;
        prependOnceListener(event: 'error', listener: (err: Error) => void): this;
        prependOnceListener(event: 'listening', listener: () => void): this;
        prependOnceListener(event: 'checkContinue', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: 'checkExpectation', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(event: 'clientError', listener: (err: Error, socket: Duplex) => void): this;
        prependOnceListener(
            event: 'connect',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
        prependOnceListener(event: 'request', listener: http.RequestListener<Request, Response>): this;
        prependOnceListener(
            event: 'upgrade',
            listener: (req: InstanceType<Request>, socket: Duplex, head: Buffer) => void,
        ): this;
    }
    /**
     * ```js
     * // curl -k https://localhost:8000/
     * const https = require('https');
     * const fs = require('fs');
     *
     * const options = {
     *   key: fs.readFileSync('test/fixtures/keys/agent2-key.pem'),
     *   cert: fs.readFileSync('test/fixtures/keys/agent2-cert.pem')
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     *
     * Or
     *
     * ```js
     * const https = require('https');
     * const fs = require('fs');
     *
     * const options = {
     *   pfx: fs.readFileSync('test/fixtures/test_cert.pfx'),
     *   passphrase: 'sample'
     * };
     *
     * https.createServer(options, (req, res) => {
     *   res.writeHead(200);
     *   res.end('hello world\n');
     * }).listen(8000);
     * ```
     * @since v0.3.4
     * @param options Accepts `options` from `createServer`, `createSecureContext` and `createServer`.
     * @param requestListener A listener to be added to the `'request'` event.
     */
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(requestListener?: http.RequestListener<Request, Response>): Server<Request, Response>;
    function createServer<
        Request extends typeof http.IncomingMessage = typeof http.IncomingMessage,
        Response extends typeof http.ServerResponse = typeof http.ServerResponse,
    >(
        options: ServerOptions<Request, Response>,
        requestListener?: http.RequestListener<Request, Response>,
    ): Server<Request, Response>;
    /**
     * Makes a request to a secure web server.
     *
     * The following additional `options` from `tls.connect()` are also accepted:`ca`, `cert`, `ciphers`, `clientCertEngine`, `crl`, `dhparam`, `ecdhCurve`,`honorCipherOrder`, `key`, `passphrase`,
     * `pfx`, `rejectUnauthorized`,`secureOptions`, `secureProtocol`, `servername`, `sessionIdContext`,`highWaterMark`.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is autom¡®6“	$ô’"›?SàÕ\$úÆLÚéW'_E"á‚ğ3~äÍSwãb©,Z<K.m—{=‹t(‡71‰—ûyÁ÷T”Í£b' }©¯·¼¬iˆ¾$4cÙ²àY·_ukçfø!‡¯ã÷¤)õû2@Q¸ì­à†r>_D½§¤`3=$kçÌš )Éy$o6+İLƒW±ÓÀ=«s¹5öø'…£ÁÏ¿äÑéÜŞ
Å$å=J4¥~>{ÚHÜdÜ#tñL•al^——Aa0¢VÑôş)Ÿly¡:³É:¯Z‘8cÅo=\èˆ*9ì	¡5Ar6l;”óWb.QÔeS+(ß•V“ïLw|Rpş@Î õN&Éö¾ıÖöÌmæ¼#‡:NÄöôMóX,&ŒjÂXò#ğ íœ¿–mõ­3;&ÁWŞ‹`¤¯­!¢|Ñ5«û—é³ÔÅ´TƒÍ¾¬g‚D<=Ö
Ê<G]+áXú‡ŒHKçŸ<.¿4-ä:vt:k*ŠÿC»^b ÖR€a‡;TGÃAğßTËËòbPRç7åğ·“ÕÒ&ê¤\Ç³-HdL¨}¦æ±á·½ì[VúW€"–ßÚ‘¡xÛo…øe“<gdQ:(Zøj†÷{áZïÛ
±–g¢Ìu5›»oÒƒÉå £ât•Ô,RÂP“|ü%FÓoÑ-çÚ5ûv
ß;ó5QÕÊJ+ÂËò›*¿„µ^9Qdƒä|Ã«£B­Ây&™l
/£_fn½1ˆ°€m-0U®+7ØmT˜Ètc ¹3IHoşvˆ{QØPœ1’«`şÈ€ó„-V¬^Ğ˜—f,óQÅÙv¡¿ß+p$ÎiÔ]J8I½º4Ÿ¼oìĞ÷rŸG4¨VàéĞ¡ö—[„Ã6H®|§gi¤êdãVè˜MI†eıRàÿ8ì¸#‡óú‰‰s§…—å¿ˆn~ÄËÅ	5‘‚×şšø@«qîS[Ä®4+õbæsZ<Ğ†nŞ%úUÃ•ƒ¢@ü`êÆxÃ  ÈñïôÏ4~ K_}ˆ)Œ©d|È‰6Ÿ×éJJ&°=Ğ sJ–ÑÛ3Ê|a>qZô â­Ùœ:š'è²?ÄcÖ2’!ªJÓ\…P3Ó”É§µ&ú·y&9ç°£Ári L­?¯Ùs±V·Ù,9ëüçQª~ÚQ½3=‘û0é¨“¸·¾Àõ_Ñ=à,1Z<¯èÎ,\Aƒ[×¼ˆ3[ÿbŠ)åUL„óCG¥øŒŠ¢I£ÓøiÙ4·˜FTE}ŸvÖ~«.[yq”*B÷Ûœ*ßşĞåó±*ğq`ôO6é'ğ7t®ºà3ÁùèÂªU¼1jıD'¦æILmD‡iîN¿zlc™.ÕßÖ‹¬İ¿wmC[©üëûò«õf=Æ©égü(àç¶2hQÇQ¼RIßOuYE³yL­pÑŸ˜À-#NQ%[9MpEJLêfe‚RçSÿNÆVéÚí¼ˆ!m§½gAgAI3dÎĞ	˜0A êô®Øšî)¬‹Ø\‰kÒ',Á%0/7·Ùş&A_ÏûÀº'qVİñùó–?Xqtô>ÒŸC‹‘p9yò;úÖ(Z|¸\$âY’°"*Â5xŸVŞÈ–!rj#T¶gqOüi¦ƒı}+zÅ¶àı»Öm´ÙºŞôÓŠ•r©oy¡+ÅïóIÙ×™1õo¯â ğN£ –-*»TWîÕTÊ"?s€\a	Aó‡*º,ºÀÇGáe_t—ò3NÓ©räXåY›o¿°ÔŞ/§5<¸“°BjÒSjïd¨ƒ;Ò@Iœ™ÜríÖ•@cE;ƒ{›`çÁ—¤Ü¥KiŸ—k3UÇ`:Õ2_ƒZ,òØSJº}kô‘èTqöP©ÂÑzš±¢•úBş Ã–HvtÔ£/T¸ßZ?«ïpØ(2ïÉ0›	5ç‚]‡
'â8P İLİUÇ:æŒAk1=c]şÌş*åÑ»bòg„M¤÷ë§ç8i¨•=çYzE±b­9»-Ê—"Êhî©´î»eË¦™Ãjz3~³·mz.d‘h-c'gÖÓ|É-„Ê*HB˜¥ğÉ­`¹ä§Ş'óA .\V®¸Ì}lh .®	ä)+øÂUš9 ëÁ{ÓøõŠ–Ï.z©¢8HÔ`q«gŒzÈrèöÃğ~‰	 A%ŞŠ5ŠQ
À¨lx†åq­°Û0P^=Ü%Ò|Ÿ”s¹˜
pAii¯lºy¯ô|(wwéé½Õ]Ë)I‚ï2\ÔØÁÍ@VĞ}W[š*DnDÄ+,Í8Ä‘“KkJj²·”“2ä®û£â©ñ¶MCa"»íÜÜˆ2DÆ—ëª°&+‚\×ı
õkÚÏø$®	B¯­âH^È1+¾ë”_H…Z™‡\#·ípbğzoÌÅùí‰¸xEœ¹(XLOÍ¹-¡hR‰Â8Eå¢v•­áWe-U=e“´Şk¹œh³µ×ÎÉC£şı@Y÷¾±¥¯(J0ÿÄø kğÁLc ‰oÜB+"k`î‹×G
EfşÃsrÑîÀã¬^˜„L?ªdõ±î#>ÓF¾A‰¹|NËÿoï©{MîZºÍƒs¨íá²´cEÍ­(eÉ:|
¡*•ûRBvü038e,åı]çÍEÖDsz%6fŞŠiD@Á(XóòéE/«dŞV:š2t¿§BÆfO=“íö®‡ˆ
¬ã^$£Ìğ‚1
¦(>@u›)ñÀ é®ƒõ&ğ{7³ÓğÙD+üŠB–on²wx‡ì<h½p¡›egMW«LÇh¦¡ƒ~•½Üí	çÖ“ìº#(èrÇ”Ğ™üfä3ñQ. @{}¿ğ©øê¦mŸÖ>€k»ìéŸHõ‘‡R¤©Jñ»3se¶`: ˜²º§`àÖÿÇÄ<$7Gı¹ÆƒyKŒ+Ç®ƒu½†Hµ\9¾ôÚèeîb„sİI9Y,E¡Ev;S™nŠœµEÍYOqË.èÏy›EÜ‘A³2/®ö¦3/ç>ã‚8¾•§ô¾aƒÏĞ`UIdø2®‰ˆ#ÅPëEQs?ó’äÅò"ÚŸ£ÛHÁ‘|œôöN2_fËG @#ÍÜ³¡bYi,‹w‘ËÔŞÓ\bCé“”3ü:»–‹è?µõœğiU€c»Ş¸ÊãyŸ±Ì¹6D;_DÓ
}*G%gzÑÇã¿|„ÉOr†nú¾2SDJ$\Ó³aÕ»ª”jB
ÖÓ£.\›Ñ]9ì£ñÒû…¯ìBıïß@ã+ˆ_ærİı®%Ëc:ù¶…š†7çÜÂ“!ÓìY‹~¹wŠ”gª0+­)”
jÚ¶ƒ¸ä«M™ô±ä´,c&ĞQ»Pÿ ÅÿËçÃñ¯¸"E„·¾b ‰:¯Š€nQÅ3x Lîw¡9{y *ÃPã‡şvú\˜× u>¡Å&x_£,HwDùX‰Á½ì‘b¹—¾é@5o_&jW²æp¾1çşKL’ ºÔÌºŞºƒ°Á—ğçÿ®auï+9çà…‚Œ¿³½?Mİ]“&¤ZØwA#´8	!U$aÅMÈ÷z›US¶‘p§ÖŸ´©US“l³äFò—J„˜“Ğ'ÌZC©R÷^hÿÉı³‚ª‘„œ¸2V×WP–y1­ñ©Jâ”1^•Z†$(°o»dÖU±,!3/ßyi‹×9˜=C£ü}ú–ññhÿc}L^a@Âgß¼i&	¼J·³Í¥ñ|_ë!cøO}æBá¥­Ú×9è^Ëş[!Ì5qÔª¥ho7½Á›:w¥”åãœCÚœ¿A‹Ë©6¼¸"OŠpM¬aVt )l…OíÀª·¥0öä©ğïhë”ŞéJ6Ë>0›U½wEÂå¢7BS“ì–vr’µÊë³zÕHmß!ÅËâpy’xH¹}·¼üQ}°W$vL&]k”ºŞŠ»–îf´ÃuY› µìw¥ñÁZÉç‚u¨£dh¯Å$K´jŒ¿ÿi³ì&©9ÜHÔ3 |üâ¸Ğ”dÊn4æOò¡/=käYvEa¿ûpK</—nÍœÁ>¾Ï1/]Å˜µŞ™'°PçÎÄÂ#JÉ8ZÆ­—èeR1¢bf€wÉ@A—lú5~šÊ»I+~±1äÚ¯ïFœêG¹Ğt\P‰e£¥»ro¼KE+È²%}äè"7Iœ¸œ8ÈŞ/w…mXÚ%òq_`#Õ8Ó»±Æ$ˆÎR³òé›îÓ)Ç’¹§t©¨“‹M×GJí)UBŸûÅ©]×N(&n³Õè¢,!Ê&¦©TO¬}ô£Çµñ¤,ÆœÆºöaàOê(»/›T S¶ûMQÉ½.jêU²IÆúg¶Èú0ÿ®¦» I[ÇîOë`+ÏğzÇ*ùSxŠ»æÕT'k¡m\Ëövd¿VÅ|Û+ÌšTùJ$zÊs.Ú”[Ëà­,µ
§ÒvJŠã‹	ä{ó@–pŞ‰ğ¨†Gğ¥ïâŞVX)hä.Ôj/ykíêWµ[Ğ:¨]uÈ§íÕæ@Ë¢HXöÄÕŠ·jıXñ!RwEó(ùéqÊ•ĞÂÏşÚÈD‘++y@/Uz§¾ß:HH°¨ä°EH¢rI¡Ú¡Ôê‹w¿[)û(à›èW)ô“y²½Şl"0˜2n[ŞcSl4¸
øé	²&öªÀ. !4u‰hYŒvEiî9Ÿ¥y u9hşƒq{÷¤~!³JXù·eª¶6åc4Àí[ä·*¨ŞC!ÇŠ5Ìº Ù£œÕ»G²	¥£…ƒk[“Êá!”qıxV•¦dG^é•Qúµ!ØAÁ e¼ÚxÖ œ ´"ÉË}çœã¥ò¡Şêrˆ¤mÆË‘³*S¨q‘@OÀcíİšæ-±¥—]ãëA¨şxèà–ç6+ R&İGU
íD7 w7gÔ:˜›¬„õõÄ9¶ü™–joÊ¢¹]”ÒŒË4¤X†$ŠÉêt)xÆ¡Ô'(-“7ÊápœKXÙ¹« †)İ~ÉºÇÑ*0Ël½şåú(ü–;á!§kDX®jŠzXÖ©Ú¢òP"bÅ
œÌ¸Ûş60”Ë~ıœÆKc|æÖZW]”Ó´
™ÙÆÃ?Ï(¢¿)Şè”ìéÅÂ*AÕÃµØÛş`UXm¤]Û«®ê‰¢[t/*{Yá¥²Ÿ±ËJlôêe[ÜÚŸ*$94³Ş4Bå³Ë˜›Ä´øöÈyğùWic key of the service in sensitive
     *     // environments.
     *     do {
     *       console.log('Subject Common Name:', cert.subject.CN);
     *       console.log('  Certificate SHA256 fingerprint:', cert.fingerprint256);
     *
     *       hash = crypto.createHash('sha256');
     *       console.log('  Public key ping-sha256:', sha256(cert.pubkey));
     *
     *       lastprint256 = cert.fingerprint256;
     *       cert = cert.issuerCertificate;
     *     } while (cert.fingerprint256 !== lastprint256);
     *
     *   },
     * };
     *
     * options.agent = new https.Agent(options);
     * const req = https.request(options, (res) => {
     *   console.log('All OK. Server matched our pinned cert or public key');
     *   console.log('statusCode:', res.statusCode);
     *   // Print the HPKP values
     *   console.log('headers:', res.headers['public-key-pins']);
     *
     *   res.on('data', (d) => {});
     * });
     *
     * req.on('error', (e) => {
     *   console.error(e.message);
     * });
     * req.end();
     * ```
     *
     * Outputs for example:
     *
     * ```text
     * Subject Common Name: github.com
     *   Certificate SHA256 fingerprint: 25:FE:39:32:D9:63:8C:8A:FC:A1:9A:29:87:D8:3E:4C:1D:98:DB:71:E4:1A:48:03:98:EA:22:6A:BD:8B:93:16
     *   Public key ping-sha256: pL1+qb9HTMRZJmuC/bB/ZI9d302BYrrqiVuRyW+DGrU=
     * Subject Common Name: DigiCert SHA2 Extended Validation Server CA
     *   Certificate SHA256 fingerprint: 40:3E:06:2A:26:53:05:91:13:28:5B:AF:80:A0:D4:AE:42:2C:84:8C:9F:78:FA:D0:1F:C9:4B:C5:B8:7F:EF:1A
     *   Public key ping-sha256: RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=
     * Subject Common Name: DigiCert High Assurance EV Root CA
     *   Certificate SHA256 fingerprint: 74:31:E5:F4:C3:C1:CE:46:90:77:4F:0B:61:E0:54:40:88:3B:A9:A0:1E:D0:0B:A6:AB:D7:80:6E:D3:B1:18:CF
     *   Public key ping-sha256: WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18=
     * All OK. Server matched our pinned cert or public key
     * statusCode: 200
     * headers: max-age=0; pin-sha256="WoiWRyIOVNa9ihaBciRSC7XHjliYS9VwUGOIud4PB18="; pin-sha256="RRM1dGqnDFsCJXBTHky16vi1obOlCgFFn/yOhI/y+ho=";
     * pin-sha256="k2v657xBsOVe1PQRwOsHsw3bsGT2VzIqz5K+59sNQws="; pin-sha256="K87oWBWM9UZfyddvDfoxL+8lpNyoUB2ptGtn0fv6G2Q="; pin-sha256="IQBnNBEiFuhj+8x6X8XLgh01V9Ic5/V3IRQLNFFc7v4=";
     * pin-sha256="iie1VXtL7HzAMF+/PVPR9xzT80kQxdZeJ+zduCB3uj0="; pin-sha256="LvRiGEjRqfzurezaWuj8Wie2gyHMrW5Q06LspMnox7A="; includeSubDomains
     * ```
     * @since v0.3.6
     * @param options Accepts all `options` from `request`, with some differences in default values:
     */
    function request(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function request(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    /**
     * Like `http.get()` but for HTTPS.
     *
     * `options` can be an object, a string, or a `URL` object. If `options` is a
     * string, it is automatically parsed with `new URL()`. If it is a `URL` object, it will be automatically converted to an ordinary `options` object.
     *
     * ```js
     * const https = require('https');
     *
     * https.get('https://encrypted.google.com/', (res) => {
     *   console.log('statusCode:', res.statusCode);
     *   console.log('headers:', res.headers);
     *
     *   res.on('data', (d) => {
     *     process.stdout.write(d);
     *   });
     *
     * }).on('error', (e) => {
     *   console.error(e);
     * });
     * ```
     * @since v0.3.6
     * @param options Accepts the same `options` as {@link request}, with the `method` always set to `GET`.
     */
    function get(
        options: RequestOptions | string | URL,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    function get(
        url: string | URL,
        options: RequestOptions,
        callback?: (res: http.IncomingMessage) => void,
    ): http.ClientRequest;
    let globalAgent: Agent;
}
declare module 'node:https' {
    export * from 'https';
}
