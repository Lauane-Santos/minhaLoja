module.exports = Long;

/**
 * wasm optimizations, to do native i64 multiplication and divide
 */
var wasm = null;

try {
  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11
  ])), {}).exports;
} catch (e) {
  // no wasm support :(
}

/**
 * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.
 *  See the from* functions below for more convenient ways of constructing Longs.
 * @exports Long
 * @class A Long class for representing a 64 bit two's-complement integer value.
 * @param {number} low The low (signed) 32 bits of the long
 * @param {number} high The high (signed) 32 bits of the long
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @constructor
 */
function Long(low, high, unsigned) {

    /**
     * The low 32 bits as a signed value.
     * @type {number}
     */
    this.low = low | 0;

    /**
     * The high 32 bits as a signed value.
     * @type {number}
     */
    this.high = high | 0;

    /**
     * Whether unsigned or not.
     * @type {boolean}
     */
    this.unsigned = !!unsigned;
}

// The internal representation of a long is the two given signed, 32-bit values.
// We use 32-bit pieces because these are the size of integers on which
// Javascript performs bit-operations.  For operations like addition and
// multiplication, we split each number into 16 bit pieces, which can easily be
// multiplied within Javascript's floating-point representation without overflow
// or change in sign.
//
// In the algorithms below, we frequently reduce the negative case to the
// positive case by negating the input(s) and then post-processing the result.
// Note that we must ALWAYS check specially whether those values are MIN_VALUE
// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
// a positive number, it overflows back into a negative).  Not handling this
// case would often result in infinite recursion.
//
// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*
// methods on which they depend.

/**
 * An indicator used to reliably determine if an object is a Long or not.
 * @type {boolean}
 * @const
 * @private
 */
Long.prototype.__isLong__;

Object.defineProperty(Long.prototype, "__isLong__", { value: true });

/**
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 * @inner
 */
function isLong(obj) {
    return (obj && obj["__isLong__"]) === true;
}

/**
 * Tests if the specified object is a Long.
 * @function
 * @param {*} obj Object
 * @returns {boolean}
 */
Long.isLong = isLong;

/**
 * A cache of the Long representations of small integer values.
 * @type {!Object}
 * @inner
 */
var INT_CACHE = {};

/**
 * A cache of the Long representations of small unsigned integer values.
 * @type {!Object}
 * @inner
 */
var UINT_CACHE = {};

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromInt(value, unsigned) {
    var obj, cachedObj, cache;
    if (unsigned) {
        value >>>= 0;
        if (cache = (0 <= value && value < 256)) {
            cachedObj = UINT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache)
            UINT_CACHE[value] = obj;
        return obj;
    } else {
        value |= 0;
        if (cache = (-128 <= value && value < 128)) {
            cachedObj = INT_CACHE[value];
            if (cachedObj)
                return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache)
            INT_CACHE[value] = obj;
        return obj;
    }
}

/**
 * Returns a Long representing the given 32 bit integer value.
 * @function
 * @param {number} value The 32 bit integer in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromInt = fromInt;

/**
 * @param {number} value
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromNumber(value, unsigned) {
    if (isNaN(value))
        return unsigned ? UZERO : ZERO;
    if (unsigned) {
        if (value < 0)
            return UZERO;
        if (value >= TWO_PWR_64_DBL)
            return MAX_UNSIGNED_VALUE;
    } else {
        if (value <= -TWO_PWR_63_DBL)
            return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
            return MAX_VALUE;
    }
    if (value < 0)
        return fromNumber(-value, unsigned).neg();
    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);
}

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 * @function
 * @param {number} value The number in question
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromNumber = fromNumber;

/**
 * @param {number} lowBits
 * @param {number} highBits
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromBits(lowBits, highBits, unsigned) {
    return new Long(lowBits, highBits, unsigned);
}

/**
 * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is
 *  assumed to use 32 bits.
 * @function
 * @param {number} lowBits The low 32 bits
 * @param {number} highBits The high 32 bits
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long} The corresponding Long value
 */
Long.fromBits = fromBits;

/**
 * @function
 * @param {number} base
 * @param {number} exponent
 * @returns {number}
 * @inner
 */
var pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)

/**
 * @param {string} str
 * @param {(boolean|number)=} unsigned
 * @param {number=} radix
 * @returns {!Long}
 * @inner
 */
function fromString(str, unsigned, radix) {
    if (str.length === 0)
        throw Error('empty string');
    if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
    if (typeof unsigned === 'number') {
        // For goog.math.long compatibility
        radix = unsigned,
        unsigned = false;
    } else {
        unsigned = !! unsigned;
    }
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');

    var p;
    if ((p = str.indexOf('-')) > 0)
        throw Error('interior hyphen');
    else if (p === 0) {
        return fromString(str.substring(1), unsigned, radix).neg();
    }

    // Do several (8) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 8));

    var result = ZERO;
    for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i),
            value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result = result.mul(power).add(fromNumber(value));
        } else {
            result = result.mul(radixToPower);
            result = result.add(fromNumber(value));
        }
    }
    result.unsigned = unsigned;
    return result;
}

/**
 * Returns a Long representation of the given string, written using the specified radix.
 * @function
 * @param {string} str The textual representation of the Long
 * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed
 * @param {number=} radix The radix in which the text is written (2-36), defaults to 10
 * @returns {!Long} The corresponding Long value
 */
Long.fromString = fromString;

/**
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val
 * @param {boolean=} unsigned
 * @returns {!Long}
 * @inner
 */
function fromValue(val, unsigned) {
    if (typeof val === 'number')
        return fromNumber(val, unsigned);
    if (typeof val === 'string')
        return fromString(val, unsigned);
    // Throws for non-objects, converts non-instanceof Long:
    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);
}

/**
 * Converts the specified value to a Long using the appropriate from* function for its type.
 * @function
 * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value
 * @param {boolean=} unsigned Whether unsigned or not, defaults to signed
 * @returns {!Long}
 */
Long.fromValue = fromValue;

// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be
// no runtime penalty for these.

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_16_DBL = 1 << 16;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_24_DBL = 1 << 24;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;

/**
 * @type {number}
 * @const
 * @inner
 */
var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;

/**
 * @type {!Long}
 * @const
 * @inner
 */
var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);

/**
 * @type {!Long}
 * @inner
 */
var ZERO = fromInt(0);

/**
 * Signed zero.
 * @type {!Long}
 */
Long.ZERO = ZERO;

/**
 * @type {!Long}
 * @inner
 */
var UZERO = fromInt(0, true);

/**
 * Unsigned zero.
 * @type {!Long}
 */
Long.UZERO = UZERO;

/**
 * @type {!Long}
 * @inner
 */
var ONE = fromInt(1);

/**
 * Signed one.
 * @type {!Long}
 */
Long.ONE = ONE;

/**
 * @type {!Long}
 * @inner
 */
var UONE = fromInt(1, true);

/**
 * Unsigned one.
 * @type {!Long}
 */
Long.UONE = UONE;

/**
 * @type {!Long}
 * @inner
 */
var NEG_ONE = fromInt(-1);

/**
 * Signed negative one.
 * @type {!Long}
 */
Long.NEG_ONE = NEG_ONE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);

/**
 * Maximum signed value.
 * @type {!Long}
 */
Long.MAX_VALUE = MAX_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);

/**
 * Maximum unsigned value.
 * @type {!Long}
 */
Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;

/**
 * @type {!Long}
 * @inner
 */
var MIN_VALUE = fromBits(0, 0x80000000|0, false);

/**
 * Minimum signed value.
 * @type {!Long}
 */
Long.MIN_VALUE = MIN_VALUE;

/**
 * @alias Long.prototype
 * @inner
 */
var LongPrototype = Long.prototype;

/**
 * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.
 * @returns {number}
 */
LongPrototype.toInt = function toInt() {
    return this.unsigned ? this.low >>> 0 : this.low;
};

/**
 * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).
 * @returns {number}
 */
LongPrototype.toNumber = function toNumber() {
    if (this.unsigned)
        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);
    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
};

/**
 * Converts the Long to a string written in the specified radix.
 * @param {number=} radix Radix (2-36), defaults to 10
 * @returns {string}
 * @override
 * @throws {RangeError} If `radix` is out of range
 */
LongPrototype.toString = function toString(radix) {
    radix = radix || 10;
    if (radix < 2 || 36 < radix)
        throw RangeError('radix');
    if (this.isZero())
        return '0';
    if (this.isNegative()) { // Unsigned Longs are never negative
        if (this.eq(MIN_VALUE)) {
            // We need to change the Long value before it can be negated, so we remove
            // the bottom-most digit in this base and then recurse to do the rest.
            var radixLong = fromNumber(radix),
                div = this.div(radixLong),
                rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
        } else
            return '-' + this.neg().toString(radix);
    }

    // Do several (6) digits each time through the loop, so as to
    // minimize the calls to the very expensive emulated div.
    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),
        rem = this;
    var result = '';
    while (true) {
        var remDiv = rem.div(radixToPower),
            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,
            digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
            return digits + result;
        else {
            while (digits.length < 6)
                digits = '0' + digits;
            result = '' + digits + result;
        }
    }
};

/**
 * Gets the high 32 bits as a signed integer.
 * @returns {number} Signed high bits
 */
LongPrototype.getHighBits = function getHighBits() {
    return this.high;
};

/**
 * Gets the high 32 bits as an unsigned integer.
 * @returns {number} Unsigned high bits
 */
LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
    return this.high >>> 0;
};

/**
 * Gets the low 32 bits as a signed integer.
 * @returns {number} Signed low bits
 */
LongPrototype.getLowBits = function getLowBits() {
    return this.low;
};

/**
 * Gets the low 32 bits as an unsigned integer.
 * @returns {number} Unsigned low bits
 */
LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
    return this.low >>> 0;
};

/**
 * Gets the number of bits needed to represent the absolute value of this Long.
 * @returns {number}
 */
LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
    if (this.isNegative()) // Unsigned Longs are never negative
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
    var val = this.high != 0 ? this.high : this.low;
    for (var bit = 31; bit > 0; bit--)
        if ((val & (1 << bit)) != 0)
            break;
    return this.high != 0 ? bit + 33 : bit + 1;
};

/**
 * Tests if this Long's value equals zero.
 * @returns {boolean}
 */
LongPrototype.isZero = function isZero() {
    return this.high === 0 && this.low === 0;
};

/**
 * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.
 * @returns {boolean}
 */
LongPrototype.eqz = LongPrototype.isZero;

/**
 * Tests if this Long's value is negative.
 * @returns {boolean}
 */
LongPrototype.isNegative = function isNegative() {
    return !this.unsigned && this.high < 0;
};

/**
 * Tests if this Long's value is positive.
 * @returns {boolean}
 */
LongPrototype.isPositive = function isPositive() {
    return this.unsigned || this.high >= 0;
};

/**
 * Tests if this Long's value is odd.
 * @returns {boolean}
 */
LongPrototype.isOdd = function isOdd() {
    return (this.low & 1) === 1;
};

/**
 * Tests if this Long's value is even.
 * @returns {boolean}
 */
LongPrototype.isEven = function isEven() {
    return (this.low & 1) === 0;
};

/**
 * Tests if this Long's value equals the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.equals = function equals(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)
        return false;
    return this.high === other.high && this.low === other.low;
};

/**
 * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.eq = LongPrototype.equals;

/**
 * Tests if this Long's value differs from the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.notEquals = function notEquals(other) {
    return !this.eq(/* validates */ other);
};

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.neq = LongPrototype.notEquals;

/**
 * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ne = LongPrototype.notEquals;

/**
 * Tests if this Long's value is less than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThan = function lessThan(other) {
    return this.comp(/* validates */ other) < 0;
};

/**
 * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lt = LongPrototype.lessThan;

/**
 * Tests if this Long's value is less than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
    return this.comp(/* validates */ other) <= 0;
};

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.lte = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.le = LongPrototype.lessThanOrEqual;

/**
 * Tests if this Long's value is greater than the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThan = function greaterThan(other) {
    return this.comp(/* validates */ other) > 0;
};

/**
 * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gt = LongPrototype.greaterThan;

/**
 * Tests if this Long's value is greater than or equal the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
    return this.comp(/* validates */ other) >= 0;
};

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.gte = LongPrototype.greaterThanOrEqual;

/**
 * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {boolean}
 */
LongPrototype.ge = LongPrototype.greaterThanOrEqual;

/**
 * Compares this Long's value with the specified's.
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.compare = function compare(other) {
    if (!isLong(other))
        other = fromValue(other);
    if (this.eq(other))
        return 0;
    var thisNeg = this.isNegative(),
        otherNeg = other.isNegative();
    if (thisNeg && !otherNeg)
        return -1;
    if (!thisNeg && otherNeg)
        return 1;
    // At this point the sign bits are the same
    if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
    // Both are positive if at least one is unsigned
    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;
};

/**
 * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.
 * @function
 * @param {!Long|number|string} other Other value
 * @returns {number} 0 if they are the same, 1 if the this is greater and -1
 *  if the given one is greater
 */
LongPrototype.comp = LongPrototype.compare;

/**
 * Negates this Long's value.
 * @returns {!Long} Negated Long
 */
LongPrototype.negate = function negate() {
    if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
    return this.not().add(ONE);
};

/**
 * Negates this Long's value. This is an alias of {@link Long#negate}.
 * @function
 * @returns {!Long} Negated Long
 */
LongPrototype.neg = LongPrototype.negate;

/**
 * Returns the sum of this and the specified Long.
 * @param {!Long|number|string} addend Addend
 * @returns {!Long} Sum
 */
LongPrototype.add = function add(addend) {
    if (!isLong(addend))
        addend = fromValue(addend);

    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = addend.high >>> 16;
    var b32 = addend.high & 0xFFFF;
    var b16 = addend.low >>> 16;
    var b00 = addend.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 + b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 + b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 + b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 + b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the difference of this and the specified Long.
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.subtract = function subtract(subtrahend) {
    if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
    return this.add(subtrahend.neg());
};

/**
 * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.
 * @function
 * @param {!Long|number|string} subtrahend Subtrahend
 * @returns {!Long} Difference
 */
LongPrototype.sub = LongPrototype.subtract;

/**
 * Returns the product of this and the specified Long.
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.multiply = function multiply(multiplier) {
    if (this.isZero())
        return ZERO;
    if (!isLong(multiplier))
        multiplier = fromValue(multiplier);

    // use wasm support if present
    if (wasm) {
        var low = wasm.mul(this.low,
                           this.high,
                           multiplier.low,
                           multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (multiplier.isZero())
        return ZERO;
    if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
    if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;

    if (this.isNegative()) {
        if (multiplier.isNegative())
            return this.neg().mul(multiplier.neg());
        else
            return this.neg().mul(multiplier).neg();
    } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();

    // If both longs are small, use float multiplication
    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);

    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
    // We can skip products that would overflow.

    var a48 = this.high >>> 16;
    var a32 = this.high & 0xFFFF;
    var a16 = this.low >>> 16;
    var a00 = this.low & 0xFFFF;

    var b48 = multiplier.high >>> 16;
    var b32 = multiplier.high & 0xFFFF;
    var b16 = multiplier.low >>> 16;
    var b00 = multiplier.low & 0xFFFF;

    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
    c00 += a00 * b00;
    c16 += c00 >>> 16;
    c00 &= 0xFFFF;
    c16 += a16 * b00;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c16 += a00 * b16;
    c32 += c16 >>> 16;
    c16 &= 0xFFFF;
    c32 += a32 * b00;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a16 * b16;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c32 += a00 * b32;
    c48 += c32 >>> 16;
    c32 &= 0xFFFF;
    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
    c48 &= 0xFFFF;
    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);
};

/**
 * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.
 * @function
 * @param {!Long|number|string} multiplier Multiplier
 * @returns {!Long} Product
 */
LongPrototype.mul = LongPrototype.multiply;

/**
 * Returns this Long divided by the specified. The result is signed if this Long is signed or
 *  unsigned if this Long is unsigned.
 * @param {!Long|number|string} divisor Divisor
 * @returns {!Long} Quotient
 */
LongPrototype.divide = function divide(divisor) {
    if (!isLong(divisor))
        divisor = fromValue(divisor);
    if (divisor.isZero())
        throw Error('division by zero');

    // use wasm support if present
    if (wasm) {
        // guard against signed division overflow: the largest
        // negative number / -1 would be 1 larger than the largest
        // positive number, due to two's complement.
        if (!this.unsigned &&
            this.high === -0x80000000 &&
            divisor.low === -1 && divisor.high === -1) {
            // be consistent with non-wasm code path
            return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(
            this.low,
            this.high,
            divisor.low,
            divisor.high
        );
        return fromBits(low, wasm.get_high(), this.unsigned);
    }

    if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
    var approx, rem, res;
    if (!this.unsigned) {
        // This section is only relevant for signed longs and is derived from the
        // closure library as a whole.
        if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
            else if (divisor.eq(MIN_VALUE))
                return ONE;
            else {
                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
                var halfThis = this.shr(1);
                approx = halfThis.div(divisor).shl(1);
                if (approx.eq(ZERO)) {
                    return divisor.isNegative() ? ONE : NEG_ONE;
                } else {
                    rem = this.sub(divisor.mul(approx));
                    res = approx.add(rem.div(divisor));
                    return res;
                }
            }
        } else if (divisor.eq(MIN_VALUE))ä}åã½|ãFHë)ÃY÷¾GfèK™$ôq´µ^ö—^hú+]øÙá»ˆşÂ-n^" •ã›aoïëòŸÃ#ŒsÀÏâ¿ ¥²¦İÉs°y„Ï€_§?w‚x¨_á%¼ÌQÖº•Kc¯/"–FhAXË’ªy g€Or}EhXkÁcò¥ÎGJËÂš1éYOßÜÚ5\v:;}ZÌvã5‹ª¹š@ñUù4˜œ ¢îTª¹+mµ¤z
ö†ßækÓî$% û„ÿ pöÿ €>„W… )Àã¥nåt`}JŞ6øÿ Zgü&cûÿ ­|½¹½M›ÔÖVõñßıj<c»øÿ Zù{zšMÍêiú¡û ßhxgS—9o?ú)+è±_ÿ Á<I>ÕÁÿ  ¡ÿ ÑWØ QE QEÿÙ    CMMM¸(  ×ogø	é        \(     À       `
Ü(æÊgƒQÂcNgÓv1 3 e 9 0 9 f 8 6 7 6 f 8 f d 7 ÿØÿà JFIF       ÿÛ C 						ÿÛ CÿÀ  À " ÿÄ           	
ÿÄ µ   } !1AQa"q2‘¡#B±ÁRÑğ$3br‚	
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyzƒ„…†‡ˆ‰Š’“”•–—˜™š¢£¤¥¦§¨©ª²³´µ¶·¸¹ºÂÃÄÅÆÇÈÉÊÒÓÔÕÖ×ØÙÚáâãäåæçèéêñòóôõö÷øùúÿÄ        	
ÿÄ µ  w !1AQaq"2B‘¡±Á	#3RğbrÑ
$4á%ñ&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz‚ƒ„…†‡ˆ‰Š’“”•–—˜™š¢£¤¥¦§¨©ª²³´µ¶·¸¹ºÂÃÄÅÆÇÈÉÊÒÓÔÕÖ×ØÙÚâãäåæçèéêòóôõö÷øùúÿÚ   ? ûx®°.­Å·–¶>Wïııüãó°ç#Ù##]h¬0‘Œéß?¦ ©a¢úf‘ãûD¨xaåqé˜ô9¥q³&cY‘o¶0 “·‡Ü>]Ã©Ç4[ñ$±ksÛ~è;¸úã­jÄ[`ó1¿8éøöô¬Ljê²òŸ;vs·iÆÌı¤çøsßˆÍâ¤'jê:}ğz¹= ÎqÏõeÔz“I#[¼B3†V$I“’ÄPŒ` Aç¥cë1İ5Ây;GÌ¥ò¤åqÎÜcœãñÖª+x¤ÈÛ–Ø&89s“ëŒô¿­O ×Ã8Ãrpúu$ÃŸLñœU"@£zÊè*XÇˆâÂ’1Ëp9ÏNı?Zr.¸Xî11½.ßOz°±½¯J67¡ü©ş!õ9yn}ı¹çúU«xõfqö‚0r·^İsÇå@¼¶ô?•ĞşU¯¶NœçëFÙG9¤FÆô?•ĞşU¯¶_z6ÉïEÀÈØŞ‡ò£czÊµöÉïúÒí—Ş‹±½åFÆô?•k…”œsùÑ¶Oz.3#czÊè*×Äôm“Ş‹ˆÈØŞ‡ò£czÊ¶6KïI¶OÖ‹ŒÈØŞ‡ò£czÊµöËïK¶_z.#czÊè*×Äÿ eÿ j‹ŒÈØŞ‡ò£czÊµ˜=ivÉïEÄdloCùQ±½åZûd÷ıhÛ'¿ëEÀÈØŞ‡ò¦ùRzcúÖÎÙ=ÿ ZËµ‡][ë¶¹’#dÁ>Êª­½N>s)$°T.8êh¸ù¦Hx§úW]52»’*f&!5jYºvÅBÌ}iÄšct¬ÙÓ¡NéØw¬9$o´OQüëbäõ®~i¸Qüë+”t:ŒŒ#ë\JÏ'Ûrqä7C]…ãî¸¸¹¾ğ?ş…NkQCc>Yä€Çr÷õJÙ»vûBŸ»<ŸïVÉÅÄgÒX¿U·o?×!ÿ ¦Iú6jXÅWdñtœ4RgÕôÃõÿ ŠzÛ<à?ş†ÕóåÈÇŠìÈã1Éü…}àuÙ¡[şßş†Õ™GC±}+\ğ–›®H·!K¥WE–2Q€u*rGP3‘„+¡èó§^†âËWÔ¼Çl‰DKÉGÓ|óë\£ŞM¸üí×³ôˆQgQ¾>ïÚæIÍMy«rNOzò«^ö=ê:"àº›ûìàF¯Ø_Î‡ï·ıôk$V^ÔŸÛz~œsy"Æ=Ír¥©ÙuÔúà¾´öŞ8Ó¤.OÚ[WÉê|ÅÏÑãúŸZûhÁCÀ¯†~	jvŸŠ´›˜å_³­ÆC“¬ ã’Ä ;“Šû¬ò¥zT“q×¡âb­Í§Tbİ¦:ZÄ»;sôÍ«¦¼QÎ¹]JM¹úæÕŒ‘‚ØÃŠË×0ìµ™çe““÷‡şÉV/§ıáûãùŠÈY	hñıáÿ ²Vv4=ÀW
º]Ì’r‘¾Iêp#RkU¼g¢&U¦Õ‚2í$†$§ Àƒ¸p9¬_†‹æi÷) Ê™  ò1®:ë—GÓ”‚¶ñ½0‹ÇÓ+Ó†Ç,·(èŒ‹"\FÈÏ°0änÀ=GÇ=9âÍU˜\FÛX©¨#·éß¯nÕ|èÚq }š,¸‹×¦zuàsíJt=Ø³[ÄY²	(¼ƒÔ+BGi÷Öš¤æÑƒÄ{Š·µ}Gom¤~Uº,h?…@òT´æf˜ÃŸMñ^¥&:™óUbëš³qĞÖ|ŒšÂG\Q!n*%|ƒšˆËÅF‚+&Î¸¢µä›sèkÍußê­p#Ğì¾Õ·—‘›b`z“ôé]Æ·(KYw ‡šæí5{dhÜy$íA<÷÷¯>µG[‡U/wdq¾+^éw"?ØÉmô’3½A÷ñŸjÛ°Ô-ï® º¶`ñK…Xw‡â>†³¾'¬2ø}æÛ¹Gr:èkÍ~k3Ï$–r¶c‹qŒz#ØessYRÄJ_8œ4i¿wfzF£>É3èğÖºAò¿ëŸò"¸JãsíÏ$Ãüñ]uÜ›¢…ÿ é›1şÜ¥sÌq±~ü…ñ.ßŞüv¾ŒğxÆÑæÆ¾pÕ?ä9¥·©qÿ ×Ò]º=¿û¿ÔÒê#hQH(Í |ãÓå›âÉö­ªÙäã{¶}9“lWÌ¾%{¨çyn/ y8íÓ¥})ã	ÖòÚá”üËp?İÛ´ş*Gë^1®øzÊì³Hƒ{Ÿr:}1\—WÔ÷%öş¶2¼#s5Ø1¤Í'Aó­sş)66š£ÅyÜ¼dwàé]—‡´øôË©ìFksÄ6Ÿ=òJÊ¢~	ÏL×7:LéTİ¬tÿ ­#R°U‹ìñµÌon$\¿Zı#¯Ï=àYC×İ1aÛNGò¯ĞxœÈÛ‡Ü*¤Ï?Òº(»Üó1qµŸ?h¿ˆ6ğÎ·£è~–(¤¾ŠwÈˆØòğw~UrM|û­x«ã5æïøšÆS¦bxğOQÔñ^·ûU[½ï‹´kXÆd’Âñg,U@ÏÎq_9Oc¬ßi·2}¥xbmÄ»ÿ ‰æº¹9¤—~¾}6ÔcÌúoéÜ‹R½ø¡4Á.µ·$x¹#Œäì+>_øº÷m×2	Ç763İ;Ê³¾#øN¶úÔSŠægd2ÄuH™Aç2n#œ}ÑïŒK_MrŞKU •oª§ëSR<®Ûõûõ*›sWØû»ö8Ñ¦Ğü)¨Á=Èºw¾ß½wq˜PmËsØŸNkÖb½ñl!¾„BJ¨µy6—ÀÜÄ«™Èl‹ÔzWşÅWsáIœäCù:ö§›ÃÚ¨kó{"©m¶âD€nÀF8Ç9÷­#±ËV-½.­®š_Éèô4Vû^ã6qs×÷İ>Ÿ/5¡¦µûyŸmT\7É·ºûòyéúñX¦è1ã}ôƒ 0Íäƒ òùú:ô­l"GŠÆs0-™Œ¤ÇV,@8àp:Õ2këğF°®WÆQx‚_³®‚pw1”ä—ŒuÇ9Î:¹+ªQRjy‘4ÒŠI:W®Ï"}ÉÀ53åj]>°n%ùrÈô +Ë·MŠbsš§$Ù4A&sX³­µèş×o$!Š3©‡P{îJå'Ğlo´ÑüöiT©wV"BN~b{g‘ÆAôÅtÚ¤˜›°ç¼s\î©YšXÓË†\†9ä£éß5äâw>›.Šqwş‘§¬hÿ hğÜÖ21—)…ßÉÏnzñÛò¯ğO„/|ªŸµ•ÿ IMË·° Œ~¹ôæ½ûQ+ibe#p zâ¼šMsOÖõ8n4Æ/n7 Ç¹ –À=²p>+Îƒ|Ç^.ä¿U±©M²oûö&®êY	µ·ÿ qÅyÆ¯&%?ğÑ«Ğ‰°·o÷Çé^İ3äjºÄ¤jšL÷ŸÕ}7áƒ&ßıÁüëåİqöŞiÿ Mş‚kê
Ú5«Ó1[w9Í‘IŞ”UkÛØ4øÍÅË¬p¦K3 )üû½ŠI­u‰Ôf8µ#¸úoÏæ€Ws¶HÉï^Ÿ.š`´Ôô˜åófÔg2|‡
¤Ø9Ë1îÎ|ï6·u¦Çp—<¼G×©¡®'ıv=ïj“Óm>ş¥¿í¨4{Ïôœ‚í÷»ÛõíZWş ‡_œ½²öçk>s½HãØæ¼¿R}KZÄÒ&#=3øÔ¶Ú6°-æ»³•G–70İ“ş.š±¢ªï{h{•Î½¶…3nÃym·ëé^muû@øÎ@ö­ŞĞ ÎÃ½Mà_;ÅQZÍ‰â&–XXGŞRG#p sT¼ğ+Sµ²øZ'¸Ñù/-=¹îG/ş!~øÉê¡TpbeÌîfÜ|_ñô©qs}<³GÂ<]”p¥‰ g*h>,jïv.î¤óä#_ïŒ}î¼•ä»™zqVmnpØ5Ò™ÀÕô=Ç¾/Óu¤··İ$RCko¶İØ)–-GŞbOµexfü^\É)¸is¹6ä“–ÉãÓ½C„¤ñ=¿Ú-äHÖŞ'iñÀÁP:ä’[ğJw„ô¯°_İ[;«|ˆU‡B7ğyädş"±›Mùî8Mìºî~“~ÅºSCğşêyÅíÛ¾:»0TŒ˜.sÇ'ŠúÛAÓmmÖÑ-ÔÂ„•V€'’~lšùÇö"»¼—áÕÕ›¨Ym.ŞËÁ¾Een9 –äuë_B‘âA´ÛÇ9Œäã§=1Ÿ|â©÷.6‹§9ÜÖÑ“€9E8 ƒÛ¥OkckdXÛB‘–ë±Bç3Œg­UÓ†­¿ş&NÌqåîÎxõã}úV¦($nãèhÜ};b€<¿5Ì6ĞXb«Ü?É^«<•¹™w.3Šçî¤$ÖäÜšçî®9®Y„ÍqóSmîqšË»¹ÁÎjµ½ï^k;°4ïæWR¬zŒ¥déÚ²Û±µt<Ûñªš– Bî^OSŠÈÒåó·19uv?^+ÈÅIKE÷ŸE„§:k™«'ÑîüÎÇÄxô;©æ?r	
¯`všñŸDÖ‹kÃ°ú¦½Å-ß‡§Š/¾ñ>¸¯3[yMİ¬p§)¹äÇl§ùƒø×‹Kâù˜¸¹Fë}Šº³nŸoı½¦ŸnÚqúó=^àG++pFxÿ 
ô¨˜6oß÷ü}E#ä*i¹{^9}!üöAÿ šú›ÂŸòµÿ ®b¾Sñá4–ÿ §ˆÿ •}5ááÿ Å}‘æ”&¼xãøVõ1EÏxŞËÃŠÉş²ä ïè9úWÏ>4ñ®£âl­ÌÄÂ§!z ú(ê~¹5âM{1y³1bNzšâuÖ’E·ÉÆ„l‡Ú_«^»E÷c¡,zŸ`:_7üS‘tír}€ş÷.W·^{®™>Ösêì+Ç¾/Ù"ê]J› $£‘èİóì@¨f‘wg"ºÅ¾§¦¥¬¿+q‚;c½:bÓLÓå³G$È>f5ÎÜøbş93jÁ¢<ƒŸZWĞ.-ğ×'t…DÛ¶kËßäv©ÊÖ·•üeøj-¬®u6yªû(ÿ ×è+Ø<«Ée˜†88è?Èûó\/†4µĞ<<°/ŞòÀ'ßş¼Öå¾ëYQPã1¯ò®ƒ‰³¡ñGÃ |B„®±h,¯ää^Û(GÜ{¸Ë“Ÿ½¸> ó_3|VıŸ|EğÂíMé£ \ÂÛŸ»æ¡ÉLô\ñœâ¾•²Ôú¦ù³Ø×g¢ê‘Ì§\šÑÆÙ"B§ªr
ŸB*®M‘ñŸÂ+»Q¨KĞ	Æ9íœgÿ ­YÚMq®_>Â‘ 8 m:góãßÚxËáûü8ñä–®İ6ì=Å£òùl~æ}bl¡Ozª?ypñùxÏÎN?>”§e¯âf–§Ü_±ÕÚişÕî¦'d7#c®'ø½;á·Å¦ñÍåÍÕ°¶x¢•bÀÄN0ù2	Á ç•æß±tAüªE(¦ü†H0¦}ˆ"½ÃÂ¾ Ğ¼,Óé12I>bØPrs÷PÀÒ²WĞ«­o¿O"øñnÒüõŞN6àç?İÈã>Àj1ã=“ÎûJlO<cÏæ=~ğõ²¶ğ¨cP  8úRı–üŸ ­JG^°«|%nÇ—jøItç·¸¸…üÔ¶]Òm3Æq9ÿ ëÖ°‚01µqéH¶ñ¦vªŒğF?Z òŞ½*½Ó€†ææ¨_K„5éZ0/çÃç®ç¯_ÏÉ®nş|W<È²¥õŞ(‰ÈšUÆùycè£¯æHÇãYÜî”zt7%o$™ÜUR}‰ ãó5æâdÖ‡ÕåT“n]´^^‰§*¤ûÚ>PH?îõşt–újÚLdï?OóëNÓ?ykHzdŸ«Öåœ’ªÉ	Ä‹Ï#ƒìkÉkCêæ”´'º¹[ˆ~ËpØöïT Óm­d’e;	ã€:üÏáO>gÊXÎœß8äy¬;;˜Ù#Å~ƒ[³“Ën@ùÿ e> ş•|[K9ÖG;)œØòZh\©ÚÇ%H=Ô?—å\œ¬Ö1<+Ê¯ø• ş£?z4'f|şaE8óuÛÔê¼I&m4¹=.b®çâ7‰Ôèºv—cË„<˜î[ üó¯8ñùÒ4×ÿ §˜¿Uñ^ ^b™?(Qü«Õ½Ùó)··£Ìİ7XÓL^é‰è*ÕçÌFåªûè
D—|ÌO­…TºšÚB±€Ãq<×¯Mq¬^Üéšˆe#jm\OF'’H>˜®Ë?1c×5‹¨Aºø·v®hÉYçğıÉ±»<ò7fˆş¾‡­oé6QÀ£\Ô¼*WËP2rÇ óÓ§·>•Ñk:-®°Uo²Âá†:’?‡>‡½N`›Pao6Ôc€01Ó'¾;V
’NçD«6­÷›³x§K¸´Ú®ÉòıÖRõ­l¼ÊÓDGCŸÒ¹ÛDe+´tãŠŞ‚àHm›Ö%ı+fs\Ô¶¹ÈÒ7D®‹Cº1.â~w5ÃÜ\lyñùÿ …oi×Xÿ €€¿ãHgaãÿ /|6¦5İ}`ÆxˆåŠã ïó.;•òÖ¡må\I#;7p8Ç~1™&¾µğÖªbùÆô¯–¾9Y[øÅRÃ$s‹;Áö˜
0ÚUÉÜ€ÆÆÊã'ŒzÓ–¨³ÿ bÓu/ÃıhZ·&öA	n¼„Ø~±]oÀM?ÅVº–¢Ú’\Gmå´ïÃ]nå”1;¸ÎæL)G¥pß°¯o{à-^åYÄQê-“&8Øôì}à‰šÄtšS6m¤›À:‘ÉÀöl™½Îœ,Ÿ5µ}-Ø—/ÄÕ#ÄjÊìÅ8vìş;p? 3œñÒ˜‡Å	&ïôVC>n8çÁ<äzs¹ö˜_hŞ¾N3¿#õÏOÆ¤¾£?çüEs™‰lÒ´(g JTn 8älÒËæl>YPı·tüqçORCšZ ù5|~„®é@px'¹÷üé·3±hşkåİ¸_ìk?î~¦©^h¶›OÉúŸñ­}²9ı/™¿?‰¬.6íÔ]º‚Áúôõï\Uÿ èùªWz5¢‚vsõ?ãXri6®äÈÏ©©ö…X·‹ÏÚ3»?Z±¨x§·Äÿ }Hõëı*ŒzŸ"™ÿ xsOe1˜¾SÔdş=ë
‘ç=l>1Q¾f§†¼}¾Ñd¦º‘ã¬Œî"¸ËiĞ Xá œŸñ«+¤Yä.ÏÔÿ gì.uÿ j/3¢©#ç§ÃãEïŒóúÖZÒ^<œ¤ÿ ?ûÈtŒ~gúš>®Çı¨¼ËZ¿ŒvEq·!$éÇŞ ŸJÁÖ<X[Kƒ'æR¹'¾+ROé®Áåà‡ñª·>ÒåŒFĞ‚ƒŸñ¦°ÍUÌHò÷îVÕ<cæh–k»„3úÕ-sÅkq<ÎÒ…# ÁË}1ÀüjôÓ!DjA'‚:w¯ <ğoÀº¾ƒi{¦G-Ì±†w,ù''WR+˜ù¤O¤\Æ·T@é±Ú3îÉşzò8ãœf¬,º*3«¡’üú~™Ï¿zú½~|7ûÃHˆ÷¤ÿ âªAğá¿ıbÿ ¾¤ÿ â©Ø|çÅ·ºÜpJñÅ/›±ÀÀ`:F}5•ââLò}Óÿ 
áÁë¤Eÿ }Iÿ ÅRÃ?|4~G„÷¤ÿ âªGÎ|5ı®¾Bó‡ÎOÓ>¹öªñk[X±5÷‡ü(†½?±áÇûÒñTÏøgï†¿ô‡şú“ÿ Š .|!6¹Áæ¥‡Ä"%¶ù¸_Èçúş•÷<Ÿ³ïÃ^¿Øğÿ ßRñUøğ×ŒèğàšOş*€¹ñ¾%İ,Cw˜ÿ *Ğ´ñ9)İ÷²Oã_e?À†¹û,Ÿ4ÿ àT‹ğáÊ£I‹ı§ÿ â¨°ù—toãûİ\~UÏ|c‘<káëWTóo-¦©·–ËÎ$¡äãŒ×Øßğ¤¼—ÿ ÀŸÿ Š©m~x&ÙÃG§F¬¤2ÎpAÎyo\Iù‰»wÿ õ¶†ëÀí»®#“U‘:`#R£ğ¯xøQğjÏáƒjR-É»“Päİ°&BÜÀ`Î2f“àŸƒ4/ØêVZªÛC-é•Õ3†f~o˜p ôâğ§Äšî¹&°šÌ?ÙnZ8¿v±íÛœ  (c¸'=s»“Œ\Òi6ß%}{/àvËáM ;0€eÆ“Îzäg’p2}©ßğŠéÿ Çºş¿ë7rm-c2†89)Ç®FîÔËo\Ü0_ìû•ã-°ê~÷cÇzŒkRM´]£hè:RKL¥$PÊx ŒƒO5Ò4hÌª\ÂŒdûà~f€>-Ø*¥Ô;— ƒ4Ùâùk2¤q×ñaM`ˆ¾c]F¦»¥p:‹4Í2SÒeûã­	Ìß†:°°æ¸è>!i¯&·—ıãŠî¬¤Šî%š#•a}«X¡.)“¡^Eh¬\R›`ıFjÈgğêmÿ -àÃÿ ‰¦mSşz·ı÷ş]³SÆÑJlû¢©6$)muošfÿ ¾ÏøVµŒs*í•Ëês[ß`_îŠ>Îªzr*îh‘HÇÅ}=ğğãÃ#Ò!üÍ|Øc¾ğmğí—ırÎ¤³°Y8§ï5MeâçRqî%ß!
ƒ©<õ5Æßü\ğ+C-à,¼€°üÀ"¼WÇş5Ô¼Sª=¤R4ztLUQr7`ãs×8éĞWWáÿ 	øv{t'ïYG^F~•Ï:ªtè9.Ç¨ø{ÇúŠÅ¦]+Ê?€å[ğü3] vèkæSÀcwö.UÕ²¥~R=#Ò½«Ášåİı’Ûê?ñù˜tqĞ0>¾£Ö¦5c-‡:.*çNÎj2Ş´İù¨YÈ'=+S”sH*2Ù¨Ùø¨¼Ú.2BàÔ*ÿ 9¦8ªşf$ïHgeàXü¸nÛ=fò@*ß…¼wá¯Is{ÛÚ¾ÉÄG•' Ù2§â³<=aı©¤j%Ìhßõê»ãÛ¸{Œä}+Ì> üñÃ½Zÿ Q×¥„$–Ëe
Û±;•N|Öàm?(Ú99f'§=T)ÂTå);I[–?Íw¯ÜhÏ¡Gÿ ®\ô~HdóİÑ=“#9éÁê=ü0²0curÀ“®1@çÿ ®k”ÌŞÎ(&³ôÍ%tİÇÍ–RØÉ•·?*ŸP²MJÖ[YrU*Hê3Ü{£Ş€>>U9¥˜|§5(’D%RĞõ¨*ÇÍ¿¼qwu¨µ•‹¯ËÕ­yv¬gÁ›«W·xëÀš-ĞÔabL¬ß)èZòoXHê³F2£­O´´­²)P÷ns‘_°äW¬|/ñ\‹t–±1Iò¯³v?Ò¼“LÓ$¾m±ñ_å]…ìu(!•Çèkªêö99WèÏª’Â¦üTöñnPGqPk2Iic,Ñğê¤Š°ál)ßfƒŸ­L–ğ(aŸõcüjOìoş¿ò«$×hw¨š%²FÖÿ çüşŠŠMYÿ Ÿæÿ ¾£U¡q^óà¦) Úúgıkç]íŸj¸³»”ÊcÊHÇœô÷ô7…[ËÑm—Ñ)3Tt¢Z¥­ß}L¸Ÿû‘;~B”K\§ÄmM-¼?sÈ«4‰…òyçéPİ‹I½¨Vf'Œšwü&·$lA^•Ãÿ h•‘•ºƒÍD×±B’6 ¯
~ó>†›åG£Gâédæg9õãú×sà˜õX-ÙØ¬­³'ß§sßŞ¾w·ñİ³·‘ä†Şİü9ñ%•çˆìlVW™>àçq¦Ó&¥DÑö›5’Õq%E$•ë%i0*?6«¼ÜT^u,™V’m¬½5¥âªO.K)nzg€Xµ¤äÿ Ï_ı”W^½+ŒøtÛìfÿ ®£ÿ AÙ”G`{‹EUQE |v5,i“Q
µã=ë&mcË~1X™´ØæVÃ$˜×?OLW›RmLrs¸a³^ÍñfÊğÇÊ•û,dnÉäzßzñÛË‚«¸ñï\ÕYéáÒQ¹‹i¤Ek±­ğ9b{Õ(mÚcoû`¡­XæI'©ÍušZ¼ĞÈ˜î^}½éR›R×®…V¦¥ONš÷§Åû„úåQxŠı›?û†®Ø•1¨S*/È6÷ùWª|ó Ó£ÿ G˜pT*¸ÑzRéº½”vpù‘G÷b;z¸ê®w¨À>°­df¼'­D`-Zmj#4®n‘Ì[Ãåkíÿ M š·ÿ ^½³@o/M}W‘ÜCåë–­ıô‘?“Jõ}-‚YD?Ù¬Û6H×2×ƒüw’âè&ÉØbùqê	Ïô¯l/šä~!xSş½/Ë‡j„–=÷—ñãõ”µV7¥>WëSå0ù™>órk7R²áSÒ­ë0Ígu-¼À¬‘1VSÔyRŞöF#–¼Y^.çº’jÄ>ŒÑÌ—¦½Gá‡„cºñÍµÆìEóÀ÷Q?ï¡šóë½},˜nÊw5ìnÛZÖâŒ$±?ğ"_Êº Ûw0­¨Û©ô°˜ÓNõOÍ÷¦¼ÇkĞ<[¼µ”
ªÒœÔm/4À¸ÓqU¦pG5Ÿ5’eiõo…òyštíÿ MöQ]Ø¯;øJÛ´Ûúïÿ ²ŠôADv)…QTHQEñİ\‹îÕ Õz3òVLé±ÏøâÕo4Y¢eİ‘À÷õü+æmj#—.W˜æÿ 8üëŞ¾ ø•m‰°C´Œ=Ï·Ò¼õûm5ÑErH`'äâ›Õ#Ğ¥X¶yÆ•+œ3^—á9˜¿Ú	Â(À¯+]M®îåuÀ.Ä£““€8½;F¾´KÇÍƒÎ{×}*~ö½6<úµ­.§¦i›”Ü	Á$Ñâ‹mOQ°i,fp@æ<ğÃĞzÒ¹K}~+fX£àbµlüQ+Hİ×©cÊ<ÖÇ[ºƒR…n¶$ªÓ¾†ÿ „ÓD?ÒWxçÄ¦‹X¶\,óıî ş=ëè=Ã=Í”3}š?5oº;ŒÖ|¦ÑÎşMø®~„Ó¼?Ÿøø‘ÿ 
ìÇ„ôùöşùáá=+µ´÷È®w3¢4Ï;“ÄÚ^§©Y-œ»İeèèTõìO¶ƒ†ôø\I«/ ªŒÕñ'–6÷”®Ê”yQ¤d¦™€ïYírª9®_Æ^=±ğºË9O!ÄqÁ8êO\(õÇ^(&)·eÔùïâ³ˆ¼M{·e9®6+¸­Ô°ëŠ›Åìš®¡=Üß~g.qĞsğ®B÷PòÔŒ×—%ÌÛ=¤ùU¼Y%“Q?¼8ŒtçôÏìå¦5—wxÀysJ¨¸@sÏ¦[ô¯‘şÛ…ù}+î‡6Ø¾±¶aµü Íë—ùãÍtB'Všõ;Ï6šÒqT~Ğ4ÍÅt#‰“É>*¹¸µ^Iª±›šh™Ç­Dóåj©–¢y³Å2Ofø:Û´Û¯úøÿ Ù½$W˜ümú]ßı|ì‹^œ(C
(¢¨AEPÆ¢Aš·äDmÈÍqÛÓ¼QKµD74(ÄôeÆwd`»OC*d·ÔŒ^`x~aÇïyèO õ=s\ñjjëÓæB½)QiIY´¤—“Ùş–øÿ T÷XH›)»ğâ¸=NS"ˆÇ ×¢ë^Õõo¢k|1a·Í²½p½sÛÏŒs^wâ[9´;†F<¶c`Ã:?,ñÍ`ãi#^kÃäs:…”6-æ)Ã‘Ó±úçW¼2Ş+d… “ŠÍÔ®Öè¯ şfµ4«˜­A*9ÚE{]O	£ùì\Xœ@+¤²! À+ÏtÍv8Pü«~ÓÄ9>ƒ°­¹‰=bßR²ÓìÖ¡Ú-âäÇ€rzdÆy®ŸÁìüE©Ç¤Çi$
ê|²ÄcåíŒqÇ½yÎ¯ÃsBøÚËóø×?àİ~{?ZÉpWËV&=0G5Ï[S¦™õºŠJã‡"Å8xÚjóÙÛ³¸â°/fpéèk=<m	êEx—Ä¯Šãjú6Øb³#Ïº«İ£\î#Ô{qœhÅÉØŠÍ$¯¥İµóØë> üa±ğ¤okc‰õòãª!ÿ h÷#û£ñÅ|Ãâj­÷ö…ôÆIIê{@;@+i¼â-Z8æQ	óÕ]7LˆapO¿>ùA¬¶øcâ{‹hîLpˆ¤Q -<cå#9ëÇ_æ9 ãÒqŒU·ó3‹¶¨Šiâ$gr±Ï½`N¾`bÜ{‚ÇWşÉ¹{[ƒ…F*{€AÁç¿?iÉqçp ƒÍx-:nİ:3ÔmOUóFm­ œŒíèøÇâ/H°‰ÍÅ¨ãÊ˜–‡ï/àq\tš•¥¥¼ŠÀd+˜û~Nî•×Aó^ıj‘QHûŸÁ¿ôOí…[ì÷„gÊõ?ì·FıµwBã5ùíe¬yLI9Óß5ôÂï‹k:q²½m×VÀç’Èzî1ƒëÁï[Îµ[l÷	g÷ªæâ¹ñŒ^¢«G¢¹É;¯>˜ów®3şıE5ü`„uDŸPümúMÙÿ §ı‘kÔ«ÆgHjzä«Ğ]íÿ Èj­{0ª ¢Š( ¢Š(ÿÙ    CMMMö$  ëFâ|ª‘Ít        —$     À       Nd¿Ô£.X†ãQ¥WÄ
7 4 c d 9 1 a a 7 c e 2 4 6 e b ÿØÿà JFIF       ÿÛ C 						ÿÛ CÿÀ  À " ÿÄ           	
ÿÄ µ   } !1AQa"q2‘¡#B±ÁRÑğ$3br‚	
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyzƒ„…†‡ˆ‰Š’“”•–—˜™š¢£¤¥¦§¨©ª²³´µ¶·¸¹ºÂÃÄÅÆÇÈÉÊÒÓÔÕÖ×ØÙÚáâãäåæçèéêñòóôõö÷øùúÿÄ        	
ÿÄ µ  w !1AQaq"2B‘¡±Á	#3RğbrÑ
$4á%ñ&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz‚ƒ„…†‡ˆ‰Š’“”•–—˜™š¢£¤¥¦§¨©ª²³´µ¶·¸¹ºÂÃÄÅÆÇÈÉÊ